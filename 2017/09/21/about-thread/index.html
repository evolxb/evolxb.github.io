<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> about_thread · guopp</title><meta name="description" content="about_thread - guopp"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://guopp.me/atom.xml" title="guopp"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/u/2008880411/home" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="http://weibo.com/u/2008880411/home" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">about_thread</h1><div class="post-info">2017年9月21日</div><div class="post-content"><p>很多年以前，电脑的 cpu 只有一个核，电脑的性能取决于单核 cpu 的频率，频率越高性能越好。当单核 cpu 的频率到达物理极限时，想要提高电脑性能只能开发多核 cpu 。多核 cpu 可以同时在多个核心上执行任务，大大提高了电脑的性能。</p>
<h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><p>线程是实现程序并发运行的轻量级方式。在系统层面上，程序都是在多个核心上并行执行的。但是,程序内部也会有多个线程在同时执行不同的任务。系统根据相关的调度算法，分配这些线程在不同的 cpu 上执行，并在合适的时候让当前执行的线程休眠或者退出，让优先级更高的线程执行。</p>
<p>一般来说，多现场程序比单线程程序的执行效率更高，同样的时间可以完成更多的任务。响应速度也会比单线程的程序快。但是正是由于多线程可以并发执行的优点导致多线程程序的 bug 也可能会更多。多线程程序可能会在线程间共享数据结构，这导致多个线程同时修改共享的数据时可能会引发线程直接的资源竞争。 而且多线程的编码也会更复杂，维护也会更加困难。</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul>
<li><code>thread</code>: 一段独立执行的代码</li>
<li><code>process</code>: 一个运行着多个线程的程序</li>
<li><p><code>task</code>: 需要执行的任务</p>
<h2 id="线程的替代技术"><a href="#线程的替代技术" class="headerlink" title="线程的替代技术"></a>线程的替代技术</h2><p>线程是相当底层和复杂的技术。如果没有完全理解线程的概念就使用线程，就会遇到很多同步问题，严重情况下可能导致应用程序崩溃。创建线程也会消耗计算机的资源。下面有几种方式也能实现并发，但是相比线程来说更高抽象。</p>
</li>
<li><p><code>Operation objects</code>: 将线程管理交给系统，只需要关注任务本身。</p>
</li>
<li><code>Grand Central Dispatch(GCD)</code>: 只需要把任务提交到 <code>gcd queue</code> 上，<code>queue</code> 会使用线程池中的线程执行任务.</li>
<li><code>Idle-time notifications</code>: 使用 <code>NSPostWhenIdle</code> 选项在默认的 <code>NSNotificationQueue</code> 上发送一个空闲通知， 此时会进入通知队列中，当 <code>run loop</code> 空闲时， 这个通知就会被分发到通知中心。</li>
<li><code>Asynchronous functions</code>: 系统提供了很多的异步函数，编码时尽量选择这些异步函数。这些 <code>API</code> 会使用系统的守护进程来创建线程来执行任务，然后返回结果。 </li>
<li><code>Timers</code>: 可以使用定时器在主线程上执行定时任务来代替新建线程.</li>
<li><code>Separate processes</code>: 新建进程来执行和应用程序不太相关的任务。 </li>
</ul>
<h2 id="线程支持"><a href="#线程支持" class="headerlink" title="线程支持"></a>线程支持</h2><p><code>iOS</code> 和 <code>OS X</code> 提供了几种用于创建线程和管理线程的技术，以及对线程间同步的支持。</p>
<h3 id="线程封装"><a href="#线程封装" class="headerlink" title="线程封装"></a>线程封装</h3><p>虽然线程的底层实现是 <code>Mach</code> 线程, 但是我们几乎不会使用如此底层的技术。虽然它实现了所有线程的基本功能，包括抢占式执行和线程调度的能力，但是我们一般还是使用更加方便的 <code>POSIX API</code> 及其变体:</p>
<ul>
<li><code>Cocoa threads</code>: <code>NSThread</code> 和 <code>NSObject</code> 的线程 <code>API</code>。</li>
<li><code>POSIX threads</code>: 基于 <code>c</code> 的更加通用的线程 <code>API</code></li>
<li><code>Multiprocessing Services</code>: 基于 <code>c</code> 的古老的线程 <code>API</code>。</li>
</ul>
<p>在应用程序级别，线程的状态在 运行、准备、阻塞之间来回切换，直到执行完成退出变成终止状态.</p>
<p>创建新线程时需要为线程制定一个入口函数，这个入口函数就是线程执行的任务，当函数执行完成，线程就会被终止，资源也会被回收。因为创建线程需要大量的内存资源和创建时间，所有最好在入口函数中执行比较重的任务或者设置一个 <code>run loop</code> 来重复执行任务。</p>
<h3 id="Run-loop"><a href="#Run-loop" class="headerlink" title="Run loop"></a>Run loop</h3></div></article></div></section><footer><div class="paginator"><a href="/2017/03/01/正则表达式/" class="next">NEXT</a></div><div data-thread-key="2017/09/21/about-thread/" data-title="about_thread" data-url="http://guopp.me/2017/09/21/about-thread/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"guopp"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2015 - 2017 <a href="http://guopp.me">guopp</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>