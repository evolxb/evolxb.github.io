<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>guopp</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://guopp.me/"/>
  <updated>2017-09-21T09:47:38.000Z</updated>
  <id>http://guopp.me/</id>
  
  <author>
    <name>guopp</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于线程</title>
    <link href="http://guopp.me/2017/09/21/about-thread/"/>
    <id>http://guopp.me/2017/09/21/about-thread/</id>
    <published>2017-09-21T06:23:17.000Z</published>
    <updated>2017-09-21T09:47:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>很多年以前，电脑的 cpu 只有一个核，电脑的性能取决于单核 cpu 的频率，频率越高性能越好。当单核 cpu 的频率到达物理极限时，想要提高电脑性能只能开发多核 cpu 。多核 cpu 可以同时在多个核心上执行任务，大大提高了电脑的性能。</p>
<h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><p>线程是实现程序并发运行的轻量级方式。在系统层面上，程序都是在多个核心上并行执行的。但是,程序内部也会有多个线程在同时执行不同的任务。系统根据相关的调度算法，分配这些线程在不同的 cpu 上执行，并在合适的时候让当前执行的线程休眠或者退出，让优先级更高的线程执行。</p>
<p>一般来说，多现场程序比单线程程序的执行效率更高，同样的时间可以完成更多的任务。响应速度也会比单线程的程序快。但是正是由于多线程可以并发执行的优点导致多线程程序的 bug 也可能会更多。多线程程序可能会在线程间共享数据结构，这导致多个线程同时修改共享的数据时可能会引发线程直接的资源竞争。 而且多线程的编码也会更复杂，维护也会更加困难。</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul>
<li><code>thread</code>: 一段独立执行的代码</li>
<li><code>process</code>: 一个运行着多个线程的程序</li>
<li><code>task</code>: 需要执行的任务</li>
</ul>
<h2 id="线程的替代技术"><a href="#线程的替代技术" class="headerlink" title="线程的替代技术"></a>线程的替代技术</h2><p>线程是相当底层和复杂的技术。如果没有完全理解线程的概念就使用线程，就会遇到很多同步问题，严重情况下可能导致应用程序崩溃。创建线程也会消耗计算机的资源。下面有几种方式也能实现并发，但是相比线程来说更高抽象。</p>
<ul>
<li><code>Operation objects</code>: 将线程管理交给系统，只需要关注任务本身。</li>
<li><code>Grand Central Dispatch(GCD)</code>: 只需要把任务提交到 <code>gcd queue</code> 上，<code>queue</code> 会使用线程池中的线程执行任务.</li>
<li><code>Idle-time notifications</code>: 使用 <code>NSPostWhenIdle</code> 选项在默认的 <code>NSNotificationQueue</code> 上发送一个空闲通知， 此时会进入通知队列中，当 <code>run loop</code> 空闲时， 这个通知就会被分发到通知中心。</li>
<li><code>Asynchronous functions</code>: 系统提供了很多的异步函数，编码时尽量选择这些异步函数。这些 <code>API</code> 会使用系统的守护进程来创建线程来执行任务，然后返回结果。 </li>
<li><code>Timers</code>: 可以使用定时器在主线程上执行定时任务来代替新建线程.</li>
<li><code>Separate processes</code>: 新建进程来执行和应用程序不太相关的任务。 </li>
</ul>
<h2 id="线程支持"><a href="#线程支持" class="headerlink" title="线程支持"></a>线程支持</h2><p><code>iOS</code> 和 <code>OS X</code> 提供了几种用于创建线程和管理线程的技术，以及对线程间同步的支持。</p>
<h3 id="线程封装"><a href="#线程封装" class="headerlink" title="线程封装"></a>线程封装</h3><p>虽然线程的底层实现是 <code>Mach</code> 线程, 但是我们几乎不会使用如此底层的技术。虽然它实现了所有线程的基本功能，包括抢占式执行和线程调度的能力，但是我们一般还是使用更加方便的 <code>POSIX API</code> 及其变体:</p>
<ul>
<li><code>Cocoa threads</code>: <code>NSThread</code> 和 <code>NSObject</code> 的线程 <code>API</code>。</li>
<li><code>POSIX threads</code>: 基于 <code>c</code> 的更加通用的线程 <code>API</code></li>
<li><code>Multiprocessing Services</code>: 基于 <code>c</code> 的古老的线程 <code>API</code>。</li>
</ul>
<p>在应用程序级别，线程的状态在 运行、准备、阻塞之间来回切换，直到执行完成退出变成终止状态.</p>
<p>创建新线程时需要为线程制定一个入口函数，这个入口函数就是线程执行的任务，当函数执行完成，线程就会被终止，资源也会被回收。因为创建线程需要大量的内存资源和创建时间，所有最好在入口函数中执行比较重的任务或者设置一个 <code>run loop</code> 来重复执行任务。</p>
<h3 id="Run-loop"><a href="#Run-loop" class="headerlink" title="Run loop"></a>Run loop</h3><p><code>run loop</code> 管理线程上的异步事件。<code>run loop</code> 通过监听线程上的多个 <code>source</code>, 当事件到达时系统唤醒线程然后分配事件到 <code>run loop</code>, 然后调用事件的 <code>handle</code> 函数。没有事件时，<code>run loop</code> 让线程休眠。</p>
<p>创建线程并不需要强制创建相应的 <code>run loop</code>。 当线程的入口函数执行完成，如果没有 <code>run loop</code>，线程就会结束，资源会被系统回收。run loop 只是使用很少的资源来实现线程的长时间运行。没有事件时，线程会休眠，节省系统资源。</p>
<p>主线程的 <code>run loop</code> 已经被系统配置好。 只需要在其他线程中获取 <code>run loop</code>，注册事件回调，然后执行 run loop 就可以在其他线程中配置好 <code>run loop</code>。 </p>
<h3 id="同步工具"><a href="#同步工具" class="headerlink" title="同步工具"></a>同步工具</h3><p>多线程编程的最大困难就是资源竞争。可以使用 <code>lock</code>、<code>conditions</code>、<code>atomic operations</code> 来通过对共享资源的访问。</p>
<ul>
<li><code>Lock</code>: 共享资源一次只被一个线程访问。</li>
<li><code>Conditions</code>: 阻塞一个线程知道条件变为 <code>true</code></li>
<li><code>Atomic opration</code>: 使用硬件指令来通过共享资源的访问</li>
</ul>
<h3 id="线程间通讯"><a href="#线程间通讯" class="headerlink" title="线程间通讯"></a>线程间通讯</h3><p>线程间的通讯方式有很多种，各有各的优势：</p>
<ul>
<li><code>Direct messaging</code>: 直接在其他线程上执行 <code>selector</code></li>
<li>全局变量，共享内存和对象: 比直接发送消息简单，但是需要使用同步机制来保证对共享资源的访问</li>
<li><code>Conditions</code>: 只有满足 <code>conditions</code> 时线程才能运行。也是一种同步工具</li>
<li><code>Run loop sources</code>: 通过 <code>custom run loop source</code> 在线程中传递消息。</li>
<li><code>Ports and sockets</code>: 通过端口和套接字来通讯。端口是基于 <code>port-based run loop source</code> 实现的。</li>
<li><code>Message queues</code>: 古老的消息队列方式。</li>
<li><code>Cocoa distributed objects</code>: 基于端口通讯实现的高级技术。多用于进程中的通讯。</li>
</ul>
<h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><p>下面是关于线程的使用技巧.</p>
<h3 id="避免直接创建线程"><a href="#避免直接创建线程" class="headerlink" title="避免直接创建线程"></a>避免直接创建线程</h3><p>尽量使用更高级的 API 如 GCD 来实现多线程编程。这些高级 API 都会高效的管理线程并使用更少的资源。而且代码也更好维护.</p>
<h3 id="让线程的效率相当高"><a href="#让线程的效率相当高" class="headerlink" title="让线程的效率相当高"></a>让线程的效率相当高</h3><p>因为创建线程需要消耗更多的系统资源，所有尽可能保持线程的高效。同时需要终止那些空闲的线程，释放系统资源。</p>
<h3 id="避免共享数据结构"><a href="#避免共享数据结构" class="headerlink" title="避免共享数据结构"></a>避免共享数据结构</h3><p>多线程编程的一个主要问题就是资源竞争。如果没有共享数据，线程直接都是并行执行就没有这种问题。 </p>
<h3 id="线程和界面"><a href="#线程和界面" class="headerlink" title="线程和界面"></a>线程和界面</h3><p>尽量在主线程中操作用户界面，在 Cocoa 中子线程更新用户界面会导致应用程序崩溃。但是也可以在子线程中操作一些图像数据，不如压缩和变换。</p>
<h3 id="注意线程退出时的状态"><a href="#注意线程退出时的状态" class="headerlink" title="注意线程退出时的状态"></a>注意线程退出时的状态</h3><p>直到所有的非分离线程结束进程才会结束。一般情况下，主线程是非分离的。 应用程序结束时会结束所有的分离线程。如果想在应用程序退出时在后台保存数据到磁盘，可以创建非分离式线程。</p>
<h3 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h3><p>每个线程都负责捕获和处理其调用栈上抛出的异常，任何线程上没被捕获的异常都能终止其所属进程。不能将没捕获的线程抛给其他线程处理。</p>
<p>如果想要通知其他线程有异常，应该先捕获异常，然后给其他线程发消息。异常被捕获后可能会继续执行，或者等待命令，或者退出。</p>
<p><code>@synchronized</code> 会自动捕获和处理异常。</p>
<h3 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h3><p>在线程的入口函数执行完成后线程就会退出。如果使用其他方式提前终止线程，线程来不及清理打开的文件，或其他资源就会导致内存泄漏。</p>
<h3 id="Library-中的线程安全"><a href="#Library-中的线程安全" class="headerlink" title="Library 中的线程安全"></a>Library 中的线程安全</h3><p>开发第三方库的时候就应该假设程序是多线程的。应该在关键位置</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多年以前，电脑的 cpu 只有一个核，电脑的性能取决于单核 cpu 的频率，频率越高性能越好。当单核 cpu 的频率到达物理极限时，想要提高电脑性能只能开发多核 cpu 。多核 cpu 可以同时在多个核心上执行任务，大大提高了电脑的性能。&lt;/p&gt;
&lt;h2 id=&quot;什么是线
    
    </summary>
    
    
      <category term="thread" scheme="http://guopp.me/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://guopp.me/2017/03/01/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://guopp.me/2017/03/01/正则表达式/</id>
    <published>2017-03-01T10:26:52.000Z</published>
    <updated>2017-03-02T06:49:41.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>Linux</code>中大部分时间都是在处理文本内容，而为了更加快速和自动化的处理文本，我们就需要正则表达式。正则表达式提供了功能强大、灵活而又高效的方式来处理文本。正则表达式的模式匹配可以使你在大量的文本内容中快速找到特定的字符序列。验证文本来确保所匹配的模式符合某种规则：如电子邮件地址，还可以提起，编辑，删除文本字符串。对于快速处理大量的文本内容，正则表达式是不可或缺的工具。</p>
<a id="more"></a>
<p>正则表达式是你所定义的模式模版(<code>pattern template</code>)，<code>Linux</code>工具可以使用它来过滤和处理文本。如<code>grep</code>,<code>sed,</code>awk`等工具都支持正则表达式。如果数据匹配模式，它就会被接受并进行下一步处理，如果数据不匹配模式则它会被丢弃。下图描述下这个过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">文本数据 -----&gt; 正则表达式 -------&gt; 匹配的数据</div><div class="line">                |</div><div class="line">                |</div><div class="line">                |</div><div class="line">                ↓</div><div class="line">            丢弃的数据</div></pre></td></tr></table></figure>
<h1 id="1-正则表达式的类型"><a href="#1-正则表达式的类型" class="headerlink" title="1. 正则表达式的类型"></a>1. 正则表达式的类型</h1><p>正则表达式是通过<em>正则表达式引擎(regular expression engine)</em>实现的。正则表达式引擎是一套底层软件，负责解释正则表达式模式并使用这些模式进行文本匹配。<br>在<code>Linux</code>中，有两种流行的正则表达式引擎：</p>
<ul>
<li>BRE: POSIX基础正则表达式引擎(basic regular expression)</li>
<li>ERE: POSIX扩展正则表达式引擎(extended regular expression)</li>
</ul>
<h1 id="2-BRE模式"><a href="#2-BRE模式" class="headerlink" title="2. BRE模式"></a>2. BRE模式</h1><p>最基本的<code>BRE</code>模式就是匹配数据流中的文本字符。</p>
<h1 id="2-1-纯文本"><a href="#2-1-纯文本" class="headerlink" title="2.1 纯文本"></a>2.1 纯文本</h1><p>下面使用<code>sed</code>程序使用正则表达式过滤数据.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ echo &quot;This is a test&quot; | sed -n &apos;/test/p&apos;</div><div class="line">This is a test</div><div class="line">$ echo &quot;This is a test&quot; | sed -n &apos;/tset/p&apos;</div><div class="line">$</div><div class="line">$ echo &quot;This is a test&quot; | sed -n &apos;/this/p&apos;</div><div class="line">$</div><div class="line">$ echo &quot;This is a test&quot; | sed -n &apos;/This/p&apos;</div><div class="line">This is a test</div><div class="line">$</div></pre></td></tr></table></figure>
<p>第一个例子使用<code>test</code>来匹配数据流中的文本。由于<code>echo</code>语句中包含了单词<code>test</code>,所以<code>sed</code>能匹配到该文本模式，然后使用<code>p</code>命令输出匹配到的文本行。第二个例子使用<code>tset</code>，然后文本流中并没有这个单词，所以<code>sed</code>并没有匹配到这个模式，就没有输出任何数据。第三个例子使用的<code>this</code>，这次也没有匹配成功，应该文本流中并没有小写的<code>this</code>,所以也没有匹配成功。第四次文本流中出现了<code>This</code>，所以匹配成功。</p>
<p>正则表达式并不关心模式匹配出现在数据流的位置，它也不关心模式出现了多少次，一旦匹配到该模式，则会把数据流中的文本行传回给<code>Linux</code>命令。但是正则表达式会区分大小写，它们只匹配字符序列和模式一样的文本行。匹配到的文本行中必须出现模式，而且文本流中匹配到的字符序列必须和模式中的字符顺序一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ echo &quot;There are many dog.&quot; | sed -n &apos;/dogs/p&apos;</div><div class="line">$</div><div class="line">$ echo &quot;There are many dogs.&quot; | sed -n &apos;/dogs/p&apos;</div><div class="line">There are many dogs.</div><div class="line">$</div></pre></td></tr></table></figure>
<p>上面的第一个例子匹配<code>dogs</code>,但是文本流中只有<code>dog</code>,所以匹配失败。第二个例子则成功的匹配到了<code>dogs</code>。所以模式中的字符串必须安装顺序全部出现在文本流中才能匹配成功。<br>如果只使用上面这张字符串匹配则并不能一次处理大量的文本。如果想一次匹配很多字符串则必须把它们都写出来，这并不能发挥正则表达式的强大能力，下面会介绍正则表达式中非常有用的一些特殊字符来构造复杂的模式。</p>
<h1 id="2-2-特殊字符"><a href="#2-2-特殊字符" class="headerlink" title="2.2 特殊字符"></a>2.2 特殊字符</h1><p>有些字符在正则表达式中有特别的含义，结合这些特殊字符可以构造复杂的模式匹配。这些特殊字符包括：</p>
<p><code>.*[]^$\+?|()</code></p>
<p>因为这些特殊字符在正则表达式中具有特殊意义，如果只是想把它们作为文本字符来匹配则需要使用<code>\</code>来转义。而且如果想匹配反斜线也必须使用<code>\</code>来转义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ echo &quot;\ is a special character&quot; | sed -n &apos;///p&apos;</div><div class="line">$</div><div class="line">$ echo &quot;\ is a special character&quot; | sed -n &apos;/\//p&apos;</div><div class="line">\ is a special character</div><div class="line">$</div></pre></td></tr></table></figure>
<h1 id="2-3-锚字符"><a href="#2-3-锚字符" class="headerlink" title="2.3 锚字符"></a>2.3 锚字符</h1><p>默认情况下，当匹配模式时，只要模式在数据流的任何位置出现，模式匹配都会成功。有两个字符可以现在模式在数据流中出现的位置。</p>
<h2 id="2-3-1-行首"><a href="#2-3-1-行首" class="headerlink" title="2.3.1 行首"></a>2.3.1 行首</h2><p><code>^</code>字符定义从数据流中文本行的行首开始的模式。如果模式出现在行首则匹配成功，否则无法匹配。要使用<code>^</code>，必须将它放到正则表达式中模式的前面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ echo &quot;Make American great again.&quot;  | sed -n &apos;/^make/p&apos;</div><div class="line">$</div><div class="line">$ echo &quot;Make American great again.&quot;  | sed -n &apos;/^Make/p&apos;</div><div class="line">Make American great again.</div></pre></td></tr></table></figure>
<h2 id="2-3-2-行尾"><a href="#2-3-2-行尾" class="headerlink" title="2.3.2 行尾"></a>2.3.2 行尾</h2><p>和<code>^</code>一样，<code>$</code>表示模式必须出现在行尾。将这个特殊字符放在文本模式后面来指明数据必须以该文本模式结尾。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ echo &quot;MAKE AMERICAN GREAT AGAIN.&quot; | sed -n &apos;/again$/p&apos;</div><div class="line">$</div><div class="line">$ echo &quot;MAKE AMERICAN GREAT AGAIN.&quot; | sed -n &apos;/AGAIN$/p&apos;</div><div class="line">MAKE AMERICAN GREAT AGAIN.</div></pre></td></tr></table></figure>
<h2 id="2-3-2-组合锚点"><a href="#2-3-2-组合锚点" class="headerlink" title="2.3.2 组合锚点"></a>2.3.2 组合锚点</h2><p>在某些情况下可以在同一行中把行首锚点和行尾锚点组合起来使用。一种情况是为了查找只含有特定文本的数据行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ cat data1.txt</div><div class="line">make american great again.</div><div class="line">Make american great again.</div><div class="line">MAKE AMERICAN GREAT AGAIN.</div><div class="line">$ sed -n &apos;/^MAKE AMERICAN GREAT AGAIN.$/p&apos; data1.txt</div><div class="line">MAKE AMERICAN GREAT AGAIN.</div><div class="line">$</div></pre></td></tr></table></figure>
<p>还有一个情况就是在行首锚点和行尾锚点之间不加任何文本，这样就会过滤出数据流中的空白行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ cat data2.txt</div><div class="line">make american great again.</div><div class="line"></div><div class="line">Make american great again.</div><div class="line"></div><div class="line">MAKE AMERICAN GREAT AGAIN.</div><div class="line">$ sed -n &apos;/^$/d&apos; data2.txt</div><div class="line">make american great again.</div><div class="line">Make american great again.</div><div class="line">MAKE AMERICAN GREAT AGAIN.</div><div class="line">$</div></pre></td></tr></table></figure>
<p>上面定义的正则表达式模式会查找行首和行尾之间什么都没有的数据行。然后使用<code>d</code>命令来删除匹配到的空白行，因此输出的文本流中就没有空白行了。这是从文档中删除空白行的很有效的方法。</p>
<h1 id="2-4-点字符"><a href="#2-4-点字符" class="headerlink" title="2.4 点字符"></a>2.4 点字符</h1><p>特殊字符点号用来匹配除换行符之外的任意一个字符。在点号出现的位置必须有且只有一个字符，才能匹配成功</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">$ cat zip.txt</div><div class="line">bzip2</div><div class="line">bunzip</div><div class="line">gzip</div><div class="line">gunzip</div><div class="line">unzip</div><div class="line">zip</div><div class="line">$ sed -n &apos;/.zip/p&apos; zip.txt</div><div class="line">bzip2</div><div class="line">bunzip</div><div class="line">gzip</div><div class="line">gunzip</div><div class="line">unzip</div><div class="line">$</div></pre></td></tr></table></figure>
<p>上面的例子中<code>.zip</code>表示最少得匹配4个字符，其中第一个可以是任意字符，后面三个必须是<code>zip</code>。所以最后一行没有匹配成功，其他则都匹配成功。</p>
<h1 id="2-5-字符组"><a href="#2-5-字符组" class="headerlink" title="2.5 字符组"></a>2.5 字符组</h1><p>特殊字符点号在匹配某个位置上的任意字符时很有效，但是如果想限制字符的范围的时候就没有那么给力了。但是正则表达式中的<code>字符组(character class)</code>可以用来限定待匹配的字符是一组字符中任意一个。如果字符组中的某个字符出现在数据流中则匹配成功。<br>使用方括号来定义一个字符组。方括号中的字符是你希望匹配的字符，然后你就可以使用整个组来匹配字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ sed -n &apos;[bg]zip&apos; zip.txt</div><div class="line">bzip2</div><div class="line">gzip</div><div class="line">$</div></pre></td></tr></table></figure>
<p>上面的模式匹配中的方括号就是字符组，只要匹配到其中的任何一个字符都会匹配成功。这个匹配模式可以匹配<code>bzip</code>和<code>gzip</code>。字符组中的位置必须要有其中的一个字符出现才能匹配成功。字符组中不仅能使用字符，也可以使用数字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ cat data3.txt</div><div class="line">This is test line0.</div><div class="line">This is test line1.</div><div class="line">This is test line2.</div><div class="line">This is test line3.</div><div class="line">This is a end line.</div><div class="line">$ sed -n &apos;/[12345]/p&apos; data3.txt</div><div class="line">This is test line1.</div><div class="line">This is test line2.</div><div class="line">This is test line3.</div><div class="line">$</div></pre></td></tr></table></figure>
<p>这个正则表达式模式匹配数据行中有数字<code>0</code>,<code>1</code>,<code>2</code>,<code>3</code>,<code>4</code>,<code>5</code>的行。其他数字以及没有数字的行都会被过滤。<br>可以讲字符组组合在一起以检查特定的字符序列是否符合某种格式：比如电话号码和邮编。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">cat data4.txt</div><div class="line">606333</div><div class="line">462018</div><div class="line">2230011</div><div class="line">4353</div><div class="line">51900</div><div class="line">$ sed -n &apos;</div><div class="line">&gt; /[0123456789][0123456789][0123456789][0123456789][0123456789][0123456789]/</div><div class="line">&gt; &apos; data4.txt</div><div class="line">606333</div><div class="line">462018</div><div class="line">2230011</div></pre></td></tr></table></figure>
<p>上面的例子成功的过滤了<code>6</code>位数以下的邮编，但是它也让<code>7</code>位数的邮编通过了模式匹配。正则表达式只有在文本流中匹配到了<strong>最小</strong>的模式字符串就匹配成功，上面的例子中<code>7</code>位数字中的前<code>6</code>位已经匹配成功，则整行文本都会匹配成功。如果想只匹配长度为6个数字的邮编则可以使用行首行尾限定符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ sed -n &apos;</div><div class="line">&gt; /^[0123456789][0123456789][0123456789][0123456789][0123456789][0123456789]$/</div><div class="line">&gt; &apos; data4.txt</div><div class="line">606333</div><div class="line">462018</div><div class="line">$</div></pre></td></tr></table></figure>
<h1 id="2-6-区间"><a href="#2-6-区间" class="headerlink" title="2.6 区间"></a>2.6 区间</h1><p>上面的例子只是匹配6个数字的邮编，如果我们想匹配11位的移动手机号码，如果按照上面的方式…:( 。好在有一种可以方式可以避免写那么多字母和数字。这就是<strong>区间</strong>，只要在方括号的开始和结束指定一个字符，中间使用破折号分隔这两个字符就可以了。现在可以优化下上面的邮编的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ sed -n &apos;</div><div class="line">&gt; /^[0-9][0-9][0-9][0-9][0-9][0-9]$/</div><div class="line">&gt; &apos; data4.txt</div><div class="line">606333</div><div class="line">462018</div><div class="line">$</div></pre></td></tr></table></figure>
<p>这个模式和上面的是一样的，只能匹配6位数字。同样的方法也使用于字母字符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ sed -n &apos;/[c-h]at/p&apos; data5.txt</div><div class="line">The cat is sleeping.</div><div class="line">That is a very nice hat.</div><div class="line">$</div></pre></td></tr></table></figure>
<p>上面的例子中<code>[c-h]</code>匹配<code>c</code>和<code>h</code>之间的所有字母。还可以在单个字符组中指定多个字符区间：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ sed -n &apos;/[c-hx-z]at/p&apos; data5.txt</div><div class="line">The cat is sleeping.</div><div class="line">That is a very nice hat.</div><div class="line">$</div></pre></td></tr></table></figure>
<h1 id="2-7-排除型字符组"><a href="#2-7-排除型字符组" class="headerlink" title="2.7 排除型字符组"></a>2.7 排除型字符组</h1><p>在正则表达式中我们也可以反转字符组的作用。就是匹配不在字符组中的字符。在字符组的前面加上<code>^</code>，就可以匹配字符组之外的字符了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sed -n &apos;/[^c-h]at/p&apos; data5.txt</div><div class="line">$</div></pre></td></tr></table></figure>
<p>通过排除型字符组，可以匹配除了<code>c</code>和<code>h</code>之间的所有字符。</p>
<h1 id="2-8-特殊的字符组"><a href="#2-8-特殊的字符组" class="headerlink" title="2.8 特殊的字符组"></a>2.8 特殊的字符组</h1><p>除了自己定义的字符组之外，<code>BRE</code>还包含了一些特殊的字符组，可以用来匹配特定类型的字符。</p>
<table>
<thead>
<tr>
<th>组</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>[[:alpha:]]</td>
<td>匹配任意字母字符，不管是大写还是小写</td>
</tr>
<tr>
<td>[[:alnum:]]</td>
<td>匹配任意字母数字字符0~9、A~Z或a~z</td>
</tr>
<tr>
<td>[[:blank:]]</td>
<td>匹配空格或制表符</td>
</tr>
<tr>
<td>[[:digit:]]</td>
<td>匹配0~9之间的数字</td>
</tr>
<tr>
<td>[[:lower:]]</td>
<td>匹配小写字母字符a~z</td>
</tr>
<tr>
<td>[[:print:]]</td>
<td>匹配任意可打印字符</td>
</tr>
<tr>
<td>[[:punct:]]</td>
<td>匹配标点符号</td>
</tr>
<tr>
<td>[[:space:]]</td>
<td>匹配任意空白字符：空格、制表符、NL、FF、VT和CR</td>
</tr>
<tr>
<td>[[:upper:]]</td>
<td>匹配任意大写字母字符A~Z</td>
</tr>
</tbody>
</table>
<p>可以在正则表达式中将特殊表达式当作普通字符组使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ echo &quot;abc&quot; | sed -n &apos;/[[:digit:]]/p&apos; </div><div class="line">$</div><div class="line">$ echo &quot;abc&quot; | sed -n &apos;/[[:alpha:]]/p&apos;</div><div class="line">abc</div><div class="line">$ echo &quot;abc123&quot; | sed -n &apos;/[[:digit:]]/p&apos;</div><div class="line">abc123</div><div class="line">$ echo &quot;This is, a test&quot; | sed -n &apos;/[[:punct:]]/p&apos;</div><div class="line">This is, a test</div><div class="line">$ echo &quot;This is a test&quot; | sed -n &apos;/[[:punct:]]/p&apos;</div><div class="line">$</div></pre></td></tr></table></figure>
<h1 id="2-9-星号"><a href="#2-9-星号" class="headerlink" title="2.9 星号"></a>2.9 星号</h1><p>在字符后面放置星号表面前面的字符必须在模式匹配中出现0次或多次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ echo &quot;k&quot; | sed -n &apos;/o*k/p&apos;</div><div class="line">k</div><div class="line">$ echo &quot;ok&quot; | sed -n &apos;/o*k/p&apos;</div><div class="line">ok</div><div class="line">$ echo &quot;oooook&quot; | sed -n &apos;/o*k/p&apos;</div><div class="line">oooook</div><div class="line">$</div></pre></td></tr></table></figure>
<p><code>o*</code>表示模式中可以有0个<code>o</code>,1个<code>o</code>,或者多个<code>o</code>。</p>
<h1 id="3-扩展正则表达式"><a href="#3-扩展正则表达式" class="headerlink" title="3. 扩展正则表达式"></a>3. 扩展正则表达式</h1><p><code>POSIX ERE</code>模式包括了<code>BRE</code>而且还提供了一些额外的特殊符号。下面来介绍<code>ERE</code>模式中剩下的特殊符号。</p>
<h1 id="3-1-问号"><a href="#3-1-问号" class="headerlink" title="3.1 问号"></a>3.1 问号</h1><p>问号类似于星号，但是问号和星号又不同。问号表示前面的字符只能出现<code>0</code>次或<code>1</code>次，不能是其他次数。就是说问号前面的字符要么不出现，要么只出现一次，其他情况都会匹配失败。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ echo &quot;ct&quot; | gawk &apos;/ca?t/&#123;print $0&#125;&apos;</div><div class="line">ct</div><div class="line">$ echo &quot;cat&quot; | gawk &apos;/ca?t/&#123;print $0&#125;&apos;</div><div class="line">cat</div><div class="line">$ echo &quot;caat&quot; | gawk &apos;/ca?t/&#123;print $0&#125;&apos;</div><div class="line">$</div><div class="line">$ echo &quot;caaat&quot; | gawk &apos;/ca?t/&#123;print $0&#125;&apos;</div><div class="line">$</div></pre></td></tr></table></figure>
<p><code>?</code>表示前面的字符只能出现<code>0</code>次或<code>1</code>次，其他情况都不会匹配成功。<code>?</code>也可以和字符组一起使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ echo &quot;ct&quot; | gawk &apos;/c[au]?t/&#123;print $0&#125;&apos;</div><div class="line">ct</div><div class="line">$ echo &quot;cat&quot; | gawk &apos;/c[au]?t/&#123;print $0&#125;&apos;</div><div class="line">cat</div><div class="line">$ echo &quot;cut&quot; | gawk &apos;/c[au]?t/&#123;print $0&#125;&apos;</div><div class="line">cut</div><div class="line">$ echo &quot;cot&quot; | gawk &apos;/c[au]?t/&#123;print $0&#125;&apos;</div><div class="line">$</div><div class="line">$ echo &quot;caut&quot; | gawk &apos;/c[au]?t/&#123;print $0&#125;&apos;</div><div class="line">$</div><div class="line">$ echo &quot;caet&quot; | gawk &apos;/c[au]?t/&#123;print $0&#125;&apos;</div><div class="line">$</div></pre></td></tr></table></figure>
<h1 id="3-2-加号"><a href="#3-2-加号" class="headerlink" title="3.2 加号"></a>3.2 加号</h1><p><code>+</code>和<code>*</code>、<code>?</code>类似，加号表示前面的字符最少出现<code>1</code>次。如果加号前面的字符没有出现则匹配失败。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ echo &quot;ct&quot; | gawk &apos;/ca+t/&#123;print $0&#125;&apos; </div><div class="line">$</div><div class="line">$ echo &quot;cat&quot; | gawk &apos;/ca+t/&#123;print $0&#125;&apos; </div><div class="line">cat</div><div class="line">$ echo &quot;cut&quot; | gawk &apos;/ca+t/&#123;print $0&#125;&apos; </div><div class="line">$</div><div class="line">$ echo &quot;caat&quot; | gawk &apos;/ca+t/&#123;print $0&#125;&apos; </div><div class="line">caat</div><div class="line">$ echo &quot;caet&quot; | gawk &apos;/ca+t/&#123;print $0&#125;&apos; </div><div class="line">$</div><div class="line">$ echo &quot;caaat&quot; | gawk &apos;/ca+t/&#123;print $0&#125;&apos; </div><div class="line">caaat</div><div class="line">$</div></pre></td></tr></table></figure>
<p>如果<code>a</code>字符没有出现则匹配失败。<code>+</code>也可以作用于字符组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ echo &quot;ct&quot; | gawk &apos;/c[au]+t/&#123;print $0&#125;&apos;</div><div class="line">$</div><div class="line">$ echo &quot;cat&quot; | gawk &apos;/c[au]+t/&#123;print $0&#125;&apos;</div><div class="line">cat</div><div class="line">$ echo &quot;cut&quot; | gawk &apos;/c[au]+t/&#123;print $0&#125;&apos;</div><div class="line">cut</div><div class="line">$ echo &quot;caat&quot; | gawk &apos;/c[au]+t/&#123;print $0&#125;&apos;</div><div class="line">caat</div><div class="line">$ echo &quot;caut&quot; | gawk &apos;/c[au]+t/&#123;print $0&#125;&apos;</div><div class="line">caut</div><div class="line">$ echo &quot;caaaaut&quot; | gawk &apos;/c[au]+t/&#123;print $0&#125;&apos;</div><div class="line">caaaaut</div><div class="line">$</div></pre></td></tr></table></figure>
<h1 id="3-3-花括号"><a href="#3-3-花括号" class="headerlink" title="3.3 花括号"></a>3.3 花括号</h1><p><code>ERE</code>中的花括号允许前面的模式可以重复出现的次数。这通过称为<strong>间隔(<code>interval</code>)</strong>。可以用四种方式来指定：</p>
<table>
<thead>
<tr>
<th>限定符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>{n}</td>
<td>匹配前面的元素，如果它确切地出现了 n 次。</td>
</tr>
<tr>
<td>{n,m}</td>
<td>匹配前面的元素，如果它至少出现了 n 次，但是不多于 m 次。</td>
</tr>
<tr>
<td>{n,}</td>
<td>匹配前面的元素，如果它出现了 n 次或多于 n 次。</td>
</tr>
<tr>
<td>{,m}</td>
<td>匹配前面的元素，如果它出现的次数不多于 m 次。</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ echo &quot;ct&quot; | grep -E &apos;ca&#123;1&#125;t&apos;</div><div class="line">$</div><div class="line">$ echo &quot;cat&quot; | grep -E &apos;ca&#123;1&#125;t&apos;</div><div class="line">cat</div><div class="line">$ echo &quot;caat&quot; | grep -E &apos;ca&#123;1&#125;t&apos;</div><div class="line">$</div></pre></td></tr></table></figure>
<p>设置间隔为<code>1</code>则表示<code>a</code>必须且只能出现一次，其他情况都不会匹配成功。<code>grep -E</code>可以识别<code>ERE</code>模式下的正则表达式。也可以单独设置重复出现的最少次数和最大次数，也可以设置一起设置最小和最大次数。</p>
<h1 id="3-4-Alternation-交替"><a href="#3-4-Alternation-交替" class="headerlink" title="3.4 Alternation(交替)"></a>3.4 Alternation(交替)</h1><p>管道符号允许你在检查正则表达式时，用逻辑<code>OR</code>方式指定多个模式。如果匹配了其中任何一个单独的模式则整个模式匹配成功，如果没有模式匹配上，则数据流匹配失败。使用管道符号的格式如下：</p>
<p><code>expr1 | expr2 | ...</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ echo &quot;There is a dog.&quot; | gawk &apos;/cat|dog/&#123;print $0&#125;&apos;</div><div class="line">There is a dog.</div><div class="line">$ echo &quot;There is a cat.&quot; | gawk &apos;/cat|dog/&#123;print $0&#125;&apos;</div><div class="line">There is a cat.</div><div class="line">$ echo &quot;He has a cat&quot; | gawk &apos;/[ch]at|dog/&#123;print $0&#125;&apos;</div><div class="line">He has a cat</div><div class="line">$</div></pre></td></tr></table></figure>
<p>管道符号两侧的正则表达式可以采用任何形式的正则表达式来定义文本(包括字符组)。</p>
<h1 id="3-5-表达式分组"><a href="#3-5-表达式分组" class="headerlink" title="3.5 表达式分组"></a>3.5 表达式分组</h1><p>可以使用圆括号对正则表达式分组，当你将正则表达式分组时，该组会被视为一个标准字符。可以像普通字符一样给改组使用特殊字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ echo &quot;Sat&quot; | gawk &apos;/Sat(urday)?/&#123;print $0&#125;&apos;</div><div class="line">Sat</div><div class="line">$ echo &quot;Saturday&quot; | gawk &apos;/Sat(urday)?/&#123;print $0&#125;&apos;</div><div class="line">Saturday</div><div class="line">$</div></pre></td></tr></table></figure>
<p>结尾的<code>urday</code>分组就像一个普通字符，后面的问号表示<code>urday</code>可以不出现或者只出现一次。将分组和管道一起使用是很常见的做法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ echo &quot;cat&quot; | gawk &apos;/(c|b)a(b|t)/&#123;print $0&#125;&apos;</div><div class="line">cat</div><div class="line">$ echo &quot;cab&quot; | gawk &apos;/(c|b)a(b|t)/&#123;print $0&#125;&apos;</div><div class="line">cab</div><div class="line">$ echo &quot;bat&quot; | gawk &apos;/(c|b)a(b|t)/&#123;print $0&#125;&apos;</div><div class="line">bat</div><div class="line">$ echo &quot;bab&quot; | gawk &apos;/(c|b)a(b|t)/&#123;print $0&#125;&apos;</div><div class="line">bab</div><div class="line">$ echo &quot;tab&quot; | gawk &apos;/(c|b)a(b|t)/&#123;print $0&#125;&apos;</div><div class="line">$</div><div class="line">$ echo &quot;tac&quot; | gawk &apos;/(c|b)a(b|t)/&#123;print $0&#125;&apos;</div><div class="line">$</div></pre></td></tr></table></figure>
<p>上面就是 <code>POSIX</code>的正则表达式。每种编程语言都会在 <code>POSIX</code>基础上提供更加丰富的符号集。上面只是最基本的正则表达式，其他更加复杂的就需要你们自己去学习了。加油 ：）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Linux&lt;/code&gt;中大部分时间都是在处理文本内容，而为了更加快速和自动化的处理文本，我们就需要正则表达式。正则表达式提供了功能强大、灵活而又高效的方式来处理文本。正则表达式的模式匹配可以使你在大量的文本内容中快速找到特定的字符序列。验证文本来确保所匹配的模式符合某种规则：如电子邮件地址，还可以提起，编辑，删除文本字符串。对于快速处理大量的文本内容，正则表达式是不可或缺的工具。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux regular expression" scheme="http://guopp.me/tags/linux-regular-expression/"/>
    
  </entry>
  
  <entry>
    <title>Linux find基础</title>
    <link href="http://guopp.me/2017/02/24/Linux-find%E5%9F%BA%E7%A1%80/"/>
    <id>http://guopp.me/2017/02/24/Linux-find基础/</id>
    <published>2017-02-24T03:05:33.000Z</published>
    <updated>2017-02-27T07:28:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>搜索文件在使用操作系统中是非常频繁的操作，一个系统中可能有成千上万的文件，怎么快速找到想要的文件是提升效率的关键。<code>Linux</code>中我们可以使用强大的<code>find</code>命令。<code>find</code>命令可以说是<code>Linux</code>中最常用也最复杂的命令，特别是和其他命令一起执行的时候。由于<code>find</code>具有强大的功能，所以它的选项也非常多，其中大部分都值得我们花时间了解一下。</p>
<a id="more"></a>
<h2 id="find命令的一般形式"><a href="#find命令的一般形式" class="headerlink" title="find命令的一般形式"></a><code>find</code>命令的一般形式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">find [-H | -L | -P] [-EXdsx] [-f path] path ... [expression]</div><div class="line">find [-H | -L | -P] [-EXdsx] -f path [path ...] [expression]</div></pre></td></tr></table></figure>
<p>上面的<code>find</code>命令可以简化为：</p>
<p><code>find pathname -options [-print -exec -ok ... action]</code></p>
<p>命令参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">pathname: find命令所要查找的目录路径。例如用 . 表示当前目录，用 / 表示根目录</div><div class="line"></div><div class="line">-print: 将find命令匹配到的文件输出到标准输出</div><div class="line">-exec: 将find命令匹配到的文件执行该参数指定的shell命令。相应的命令形式为 &apos;command&apos; &#123;&#125;;</div><div class="line">-ok: 和 -exec 相同，只不过更安全</div></pre></td></tr></table></figure>
<p><code>find</code>命令最简单的使用是，搜索一个或多个目录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">$ find .</div><div class="line">.</div><div class="line">./.android</div><div class="line">./.android/adbkey</div><div class="line">./.android/adbkey.pub</div><div class="line">./.android/androidwin.cfg</div><div class="line">./.android/avd</div><div class="line">./.android/cache</div><div class="line">./.android/cache/api-versions-6.bin</div><div class="line">[...]</div><div class="line">$</div><div class="line">$ find / </div><div class="line">/</div><div class="line">find: /.fseventsd: Permission denied</div><div class="line">/.MobileBackups</div><div class="line">find: /.MobileBackups: Permission denied</div><div class="line">/.OSInstallerMessages</div><div class="line">/.PKInstallSandboxManager</div><div class="line">/.PKInstallSandboxManager-SystemSoftware</div><div class="line">/.vol</div><div class="line">/Applications</div><div class="line">/Applications/.DS_Store</div><div class="line">/Applications/.localized</div><div class="line">/Applications/Adobe Application Manager</div><div class="line">/Applications/Adobe Photoshop CC 2014</div><div class="line">/Applications/Adobe Photoshop CC 2014/Adobe Photoshop CC 2014.app</div><div class="line">[...]</div><div class="line">$</div></pre></td></tr></table></figure>
<p>也可以一次搜索多个目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ find . /</div><div class="line">[...] // 输出结果太多，省略</div></pre></td></tr></table></figure>
<p>如果仅仅只是列出某个目录的所有文件就感受不到<code>find</code>的强大。<code>find</code>可以通过组合各种选项来组成搜索条件来完成搜索，而且还可以运用各种相关的操作。</p>
<h2 id="测试条件"><a href="#测试条件" class="headerlink" title="测试条件"></a>测试条件</h2><p>我们可以根据文件类型来搜索。<code>find</code>支持的文件类型如下(<code>-type</code> 参数)：</p>
<table>
<thead>
<tr>
<th>文件类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>b</td>
<td>块设备文件</td>
</tr>
<tr>
<td>c</td>
<td>字符设备文件</td>
</tr>
<tr>
<td>d</td>
<td>目录</td>
</tr>
<tr>
<td>f</td>
<td>普通文件</td>
</tr>
<tr>
<td>l</td>
<td>符号链接</td>
</tr>
</tbody>
</table>
<p>比如我们只想搜索某个目录下面所有的子目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ find . -type d </div><div class="line">.</div><div class="line">./.android</div><div class="line">./.android/avd</div><div class="line">./.android/cache</div><div class="line">./.atom</div><div class="line">./.atom/.apm</div><div class="line">./.atom/.apm/_locks</div><div class="line">./.atom/.apm/atom-autocomplete-php</div><div class="line">./.atom/.apm/atom-autocomplete-php/0.18.9</div><div class="line">./.atom/.apm/atom-autocomplete-php/0.18.9/package</div><div class="line">[...]</div><div class="line">$</div></pre></td></tr></table></figure>
<p>我们也可以只搜索某个目录下的普通文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ find ~ -type f | wc -l</div><div class="line">868386</div><div class="line">$</div></pre></td></tr></table></figure></p>
<p>也可以根据文件大小来搜索(<code>-size</code> 参数):</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>单位</th>
</tr>
</thead>
<tbody>
<tr>
<td>b</td>
<td>512个字节块。如果没有指定单位，则这是默认值。</td>
</tr>
<tr>
<td>c</td>
<td>字节</td>
</tr>
<tr>
<td>w</td>
<td>两个字节的字</td>
</tr>
<tr>
<td>k</td>
<td>千字节(1024字节)</td>
</tr>
<tr>
<td>M</td>
<td>兆字节(1048576字节)</td>
</tr>
<tr>
<td>G</td>
<td>千兆字节(1073741824字节)</td>
</tr>
</tbody>
</table>
<p>我们可以搜索目录下面文件大小大于<code>1G</code>的文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ find ~ -type f -size +1G</div><div class="line">/Documents/Virtual Machines.localized/Windows 10 x64 2.vmwarevm/Virtual Disk-s001.vmdk</div><div class="line">./Documents/Virtual Machines.localized/Windows 10 x64 2.vmwarevm/Virtual Disk-s002.vmdk</div><div class="line">./Documents/Virtual Machines.localized/Windows 10 x64 2.vmwarevm/Virtual Disk-s003.vmdk</div><div class="line">[...]</div><div class="line">$</div></pre></td></tr></table></figure>
<p>上面的例子使用了文件类型和文件大小一起作为搜索的测试条件，只有文件类型是普通文件而且大小大于<code>1G</code>的文件才会被搜索到。我们也可以再增加搜索条件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ find ~ -type f -name &quot;*.png&quot; -size +1M | wc -l</div><div class="line">5543</div><div class="line">$</div></pre></td></tr></table></figure>
<p>上面的例子中我们使用了<code>-name</code>测试条件，后面跟通配符模式。注意我们使用双引号括起来，是为了阻止<code>bash</code>展开星号。上面的测试条件是找到文件名以<code>png</code>结尾，并且是普通文件类型的文件，而且文件大小要大于<code>1M</code>。如果在数字参数前面加上<code>+</code>或者<code>-</code>则表示大于或者小于指定数。</p>
<p><code>find</code>的其他测试条件，下面是一些常见的测试条件，在数值参数的前面可以使用<code>+</code>或者<code>-</code>：</p>
<table>
<thead>
<tr>
<th>测试条件</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-cmin n</td>
<td>匹配的文件和目录的内容或属性最后修改时间正好在 n 分钟之前。 指定少于 n 分钟之前，使用 -n，指定多于 n 分钟之前，使用 +n。</td>
</tr>
<tr>
<td>-cnewer file</td>
<td>匹配的文件和目录的内容或属性最后修改时间早于那些文件。</td>
</tr>
<tr>
<td>-ctime n</td>
<td>匹配的文件和目录的内容和属性最后修改时间在 n*24小时之前。</td>
</tr>
<tr>
<td>-empty</td>
<td>匹配空文件和目录。</td>
</tr>
<tr>
<td>-group name</td>
<td>匹配的文件和目录属于一个组。组可以用组名或组 ID 来表示。</td>
</tr>
<tr>
<td>-iname pattern</td>
<td>就像-name 测试条件，但是不区分大小写。</td>
</tr>
<tr>
<td>-inum n</td>
<td>匹配的文件的 inode 号是 n。这对于找到某个特殊 inode 的所有硬链接很有帮助。</td>
</tr>
<tr>
<td>-mmin n</td>
<td>匹配的文件或目录的内容被修改于 n 分钟之前。</td>
</tr>
<tr>
<td>-mtime n</td>
<td>匹配的文件或目录的内容被修改于 n*24小时之前。</td>
</tr>
<tr>
<td>-name pattern</td>
<td>用指定的通配符模式匹配的文件和目录。</td>
</tr>
<tr>
<td>-newer file</td>
<td>匹配的文件和目录的内容早于指定的文件。当编写 shell 脚本，做文件备份时，非常有帮助。 每次你制作一个备份，更新文件（比如说日志），然后使用 find 命令来决定自从上次更新，哪一个文件已经更改了。</td>
</tr>
<tr>
<td>-nouser</td>
<td>匹配的文件和目录不属于一个有效用户。这可以用来查找 属于删除帐户的文件或监测攻击行为。</td>
</tr>
<tr>
<td>-nogroup</td>
<td>匹配的文件和目录不属于一个有效的组。</td>
</tr>
<tr>
<td>-perm mode</td>
<td>匹配的文件和目录的权限已经设置为指定的 mode。mode 可以用 八进制或符号表示法。</td>
</tr>
<tr>
<td>-samefile name</td>
<td>相似于-inum 测试条件。匹配和文件 name 享有同样 inode 号的文件。</td>
</tr>
<tr>
<td>-size n</td>
<td>匹配的文件大小为 n。</td>
</tr>
<tr>
<td>-type c</td>
<td>匹配的文件类型是 c。</td>
</tr>
<tr>
<td>-user name</td>
<td>匹配的文件或目录属于某个用户。这个用户可以通过用户名或用户 ID 来表示。</td>
</tr>
</tbody>
</table>
<h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>上面的测试条件只是一部分，限于篇幅只能列出笔记常用的。那么这么多测试条件如果都并列写在一起将不便于阅读。所以<code>find</code>提供了逻辑操作符来创建复杂的测试条件，也便于阅读和维护。逻辑操作符如下：</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-and</td>
<td>如果操作符两边的测试条件都是真，则匹配。可以简写为 -a。 注意若没有使用操作符，则默认使用 -and。</td>
</tr>
<tr>
<td>-or</td>
<td>若操作符两边的任一个测试条件为真，则匹配。可以简写为 -o。</td>
</tr>
<tr>
<td>-not</td>
<td>若操作符后面的测试条件是真，则匹配。可以简写为一个感叹号（!）。</td>
</tr>
<tr>
<td>()</td>
<td>把测试条件和操作符组合起来形成更大的表达式。这用来控制逻辑计算的优先级。</td>
</tr>
</tbody>
</table>
<p><strong>注意，<code>find</code>命令从左往右计算，而且要注意圆括号在<code>bash</code>中要转义</strong></p>
<p>我们可以使用上面的逻辑操作符来构造复杂的测试条件，例如只查找特定某些文件：</p>
<p><code>find . \(-name &quot;*.pdf&quot; -or -name &quot;*.txt&quot;\)</code></p>
<p>上面的例子会打印当前目录下以<code>.txt</code>或<code>.pdf</code>结尾的文件名。也可以找出目录下不是<code>pdf</code>的普通文件：</p>
<p><code>find . ! -name &quot;*.pdf&quot;</code></p>
<p>逻辑操作符可以描述为下面的简短形式。逻辑操作符还有一种和其他编程语言相同的特性：短路。下面是逻辑操作符的执行情况：</p>
<p><code>expr1 -operator expr2</code></p>
<table>
<thead>
<tr>
<th>expr1的结果</th>
<th>操作符</th>
<th>expr2的执行情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>真</td>
<td>-and</td>
<td>总要执行</td>
</tr>
<tr>
<td>假</td>
<td>-and</td>
<td>从不执行</td>
</tr>
<tr>
<td>真</td>
<td>-or</td>
<td>从不执行</td>
</tr>
<tr>
<td>假</td>
<td>-or</td>
<td>总要执行</td>
</tr>
</tbody>
</table>
<h2 id="预定义操作"><a href="#预定义操作" class="headerlink" title="预定义操作"></a>预定义操作</h2><p><code>find</code>除了可以根据特定条件搜索文件外，还可以在搜索到文件之后根据搜索结果执行预定义的操作。<code>find</code>预定义的常用的操作如下表:</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-print</td>
<td>把匹配文件的全路径名输送到标准输出。如果没有指定其它操作，这是 默认操作。</td>
</tr>
<tr>
<td>-delete</td>
<td>删除匹配到的文件</td>
</tr>
<tr>
<td>-ls</td>
<td>对匹配到的结果执行 <code>ls -dils</code> 命令，然后将结果输出到 <code>STDOUT</code></td>
</tr>
<tr>
<td>-quit</td>
<td>一旦找到一个匹配，就退出</td>
</tr>
</tbody>
</table>
<p><code>find .</code></p>
<p>会输出当前目录的所有文件和子目录，这相对于：</p>
<p><code>find . -print</code></p>
<p>也可以使用<code>-delete</code>来删除搜索到的文件和目录：</p>
<p><code>find . -empty -delete</code><br><code>find . -type f -name &#39;*.txt&#39; -delete</code></p>
<p>上面的第一条命令会删除当前目录下的空目录和空文件，第二条命令会删除当前目录下面所有的<code>txt</code>文件。( 好像例子不是太好:( )<br><strong>当使用<code>-delete</code>时得特别小心，可以先用<code>print</code>输出看看里面有没有不能删除的文件</strong></p>
<h2 id="自定义操作"><a href="#自定义操作" class="headerlink" title="自定义操作"></a>自定义操作</h2><p><code>find</code>除了可以使用预定义的操作之外，还可以通过<code>-exec</code>来自定义操作：</p>
<p><code>find path [expression] -exec command {} ;</code></p>
<p>上面的<code>-exec</code>是表示自定义操作的开始，<code>command</code>就是<code>shell</code>命令的名字，<code>{}</code>是当前路径名的符号表示，分号是命令结束的标志。</p>
<p><code>find . -type f -name &quot;*.zip&quot; -size +100M -exec rm {} \;</code></p>
<p>删除当前目录下大于<code>100M</code>的压缩文件。上面命令中的<code>{}</code>代表<code>find</code>找到的文件路径，<code>find</code>的结果会放到<code>{}</code>位置之中作为<code>rm</code>的参数。</p>
<p><code>find . -type f -name &quot;.pdf&quot; -exec ls -l {} \;</code></p>
<p>上面的命令用于输出当前目录下所有的<code>pdf</code>文件详情。当使用<code>-exec</code>时，每找到一个匹配就会执行一次<code>-exec</code>后面的命令。有时候我们可能希望将<code>find</code>的结果作为一个整体然后再运行额外的命令，这个时候就可以使用外部命令<code>xargs</code>。<code>xargs</code>从标准输入接受输入，并把输入转换为一个特定命令的参数列表，这样命令就不用每匹配到一个文件或目录就执行一次。</p>
<p><code>find ~ type f -name &quot;*.pdf&quot; | xargs ls -l</code></p>
<p>因为<code>xargs</code>接受标准输入，所以把<code>find</code>的结果用管道(<code>pipe</code>)到<code>xargs</code>的输入，<code>xargs</code>会把输入构造为<code>ls</code>的参数列表，然后执行<code>ls</code>命令。这种方式比<code>-exec</code>方式快很多，<code>ls</code>执行的次数远远小于<code>-exec</code>的匹配到文件就执行一次命令。<br><code>xargs</code>后面的命令并不是只执行一次，这取决于输入的参数的个数，如果超过了<code>bash</code>能够处理的最大长度，<code>xargs</code>会使用最大的参数长度执行后面的命令，然后重复这个过程，直到所有的输入都执行完。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;搜索文件在使用操作系统中是非常频繁的操作，一个系统中可能有成千上万的文件，怎么快速找到想要的文件是提升效率的关键。&lt;code&gt;Linux&lt;/code&gt;中我们可以使用强大的&lt;code&gt;find&lt;/code&gt;命令。&lt;code&gt;find&lt;/code&gt;命令可以说是&lt;code&gt;Linux&lt;/code&gt;中最常用也最复杂的命令，特别是和其他命令一起执行的时候。由于&lt;code&gt;find&lt;/code&gt;具有强大的功能，所以它的选项也非常多，其中大部分都值得我们花时间了解一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux bash shell find" scheme="http://guopp.me/tags/Linux-bash-shell-find/"/>
    
  </entry>
  
  <entry>
    <title>sed基础</title>
    <link href="http://guopp.me/2017/02/22/sed%E5%9F%BA%E7%A1%80/"/>
    <id>http://guopp.me/2017/02/22/sed基础/</id>
    <published>2017-02-22T06:02:49.000Z</published>
    <updated>2017-02-27T07:27:03.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>Linux</code> 中可以使用强大的编辑器如 <code>vim</code> 和 <code>emacs</code> 来编辑文本文件。但有时候，我们只是需要自动的处理文本文件，而不是这些强大的交互式文本编辑器。这种时候可以使用 <code>Linux</code> 的 <code>sed</code> 和 <code>gawk</code>。它们能够轻松的实现自动格式化、插入、修改或者删除文本元素。</p>
<a id="more"></a>
<h1 id="sed-编辑器"><a href="#sed-编辑器" class="headerlink" title="sed 编辑器"></a><code>sed</code> 编辑器</h1><p><code>sed</code> 编辑器被称为<em>流编辑器(stream editor)</em>, 它使用预先提供的一组规则来编辑数据流。规则就是提供给 <code>sed</code> 的命令，这些命令要么从命令行输入，要么存储在一个命令行文件中。根据所提供的命令，<code>sed</code> 执行如下操作：</p>
<ul>
<li>一次从输入中读取一行数据</li>
<li>根据提供的命令匹配数据</li>
<li>按照命令修改流中的数据</li>
<li>将新的数据输出到 <code>STDOUT</code></li>
</ul>
<p>在流编辑器将所有命令与一行数据匹配完毕后，就会重复这个流程匹配下一行数据。在处理完所有的流数据后，它就会终止。由于命令是逐行执行的，所以只需要对数据流进行一遍处理就可以完成编辑操作，这比交互式编辑器快的多，而且是完全自动化的操作数据。<br><code>sed</code> 的命令格式如下：</p>
<p><code>sed options script file</code></p>
<p>选项可以修改 <code>sed</code> 命令的行为，可以使用的选项如下表：</p>
<table>
<thead>
<tr>
<th>options</th>
<th>desc</th>
</tr>
</thead>
<tbody>
<tr>
<td>-e script</td>
<td>将 <code>script</code> 中的命名添加到已有的命令中</td>
</tr>
<tr>
<td>-f file</td>
<td>将 <code>file</code> 中的命令添加到已有的命令中</td>
</tr>
<tr>
<td>-n</td>
<td>不产生命令输出，使用 <code>print</code> 来完成输出</td>
</tr>
</tbody>
</table>
<h2 id="1-在命令行定义编辑器命令"><a href="#1-在命令行定义编辑器命令" class="headerlink" title="1. 在命令行定义编辑器命令"></a>1. 在命令行定义编辑器命令</h2><p>默认情况下，<code>sed</code> 编辑器直接从 <code>STDIN</code> 读取流数据，然后匹配命令执行编辑操作。如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ echo &quot;This is a test&quot; | sed &apos;s/test/big test/&apos;</div><div class="line">This is a big test</div><div class="line">$</div></pre></td></tr></table></figure>
<p>这个例子使用了 <code>s</code> 命令。<code>s</code> 命令是字符串替换命令。上面的例子是单行数据，<code>sed</code> 也可以处理多行数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ cat data1.txt</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">$</div><div class="line">$ sed `s/dog/cat/&apos; data1.txt</div><div class="line">The quick brown fox jumps over the lazy cat.</div><div class="line">The quick brown fox jumps over the lazy cat.</div><div class="line">The quick brown fox jumps over the lazy cat.</div><div class="line">The quick brown fox jumps over the lazy cat.</div><div class="line">$</div></pre></td></tr></table></figure>
<p><code>sed</code> 几乎是瞬间就执行完成并返回数据。并且 <code>sed</code> 并不会修改原始文件。如果查看原来的文件，它仍然保留这原始数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ cat data1.txt</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">$</div></pre></td></tr></table></figure></p>
<h2 id="2-在命令行使用多个编辑器命令"><a href="#2-在命令行使用多个编辑器命令" class="headerlink" title="2. 在命令行使用多个编辑器命令"></a>2. 在命令行使用多个编辑器命令</h2><p>要在命令行上使用多个 <code>sed</code> 命令，使用 <code>-e</code> 选项就可以了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ sed -e &apos;s/brown/green/; s/dog/cat/&apos; data1.txt</div><div class="line">The quick green fox jumps over the lazy cat.</div><div class="line">The quick green fox jumps over the lazy cat.</div><div class="line">The quick green fox jumps over the lazy cat.</div><div class="line">The quick green fox jumps over the lazy cat.</div><div class="line">$</div></pre></td></tr></table></figure></p>
<p>上面的2个命令都会作用到每一行中。使用多个命令时命令之间必须用分号分开，并且在命令末尾和分号之间不能有空格。如果不想使用分号，也可以使用<code>bash</code>中的次提示符来分隔命令。只有输入第一个单引号标示出<code>sed</code>程序脚本的起始，<code>bash</code>就会继续提示你输入更多命令，直到输入了标示结束的单引号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ sed -e &apos;</div><div class="line">&gt; s/brown/green/</div><div class="line">&gt; s/dog/cat/&apos; data1.txt</div><div class="line">The quick green fox jumps over the lazy cat.</div><div class="line">The quick green fox jumps over the lazy cat.</div><div class="line">The quick green fox jumps over the lazy cat.</div><div class="line">The quick green fox jumps over the lazy cat.</div><div class="line">$</div></pre></td></tr></table></figure></p>
<p>结果和单行输入的命令一样。必须记住，要在末尾单引号所在行结束命令。<code>bash</code>一旦发现了结束的单引号就会执行命令。</p>
<h2 id="3-从文件中读取编辑器命令"><a href="#3-从文件中读取编辑器命令" class="headerlink" title="3. 从文件中读取编辑器命令"></a>3. 从文件中读取编辑器命令</h2><p>如果有大量的<code>sed</code>需要处理，把它们放到一个单独的文本文件中是个不错的选择。可以在<code>sed</code>命令中使用<code>- f</code>来制定命令文件.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ cat script1.sed</div><div class="line">s/brown/green/</div><div class="line">s/fox/elephant/</div><div class="line">s/dog/cat/</div><div class="line">$</div><div class="line">$ sed -f script1.sed data1.txt</div><div class="line">The quick green elephant jumps over the lazy cat.</div><div class="line">The quick green elephant jumps over the lazy cat.</div><div class="line">The quick green elephant jumps over the lazy cat.</div><div class="line">The quick green elephant jumps over the lazy cat.</div><div class="line">$</div></pre></td></tr></table></figure></p>
<p>在这种情况下，不用在每条命令后面放置分号。<code>sed</code>从指定的文件中读取命令，并把它们应用到数据文件的每一行上面。</p>
<h1 id="sed基础"><a href="#sed基础" class="headerlink" title="sed基础"></a><code>sed</code>基础</h1><p>  成功使用<code>sed</code>的关键在于掌握各式各样的命令和格式。下面就来介绍下<code>sed</code>中的各个基本的命令和功能。</p>
<h2 id="1-替换命令"><a href="#1-替换命令" class="headerlink" title="1. 替换命令"></a>1. 替换命令</h2><h3 id="1-1-替换标记"><a href="#1-1-替换标记" class="headerlink" title="1.1 替换标记"></a>1.1 替换标记</h3><p>默认情况下<code>sed</code>只替换每行中第一处匹配的字符串。如果想替换一行中不同的地方就需要使用替换标记(<code>substitution flag</code>)。替换标记在替换命令之后设置。</p>
<p><code>s/pattern/replacement/flags</code></p>
<p>有一下4中可以使用的替换标记:</p>
<ul>
<li>数字：表明替换第几处匹配的地方</li>
<li>g: 替换所以匹配的文本</li>
<li>p: 打印原先行的内容</li>
<li>w file: 将替换的结果写到文件中</li>
</ul>
<p>下面看看这4中标记的效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ cat data2.txt</div><div class="line">This is a test of the test script.</div><div class="line">This is the second test of the test script.</div><div class="line">$</div><div class="line">$ sed &apos;s/test/trial/&apos; data2.txt</div><div class="line">This is a trial of the test script.</div><div class="line">This is the second trial of the test script.</div><div class="line">$</div></pre></td></tr></table></figure>
<p>原始的不使用替换标记的命令，上面的输出中只替换了每行第一个匹配到的<code>test</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ sed &apos;s/test/trial/2&apos; data2.txt</div><div class="line">This is a test of the trial script.</div><div class="line">This is the second test of the trial script. $</div><div class="line">$</div></pre></td></tr></table></figure>
<p>使用数字<code>2</code>来当作替换标记，替换了每行中第二个匹配到的<code>test</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ sed &apos;s/test/trail/g&apos; data2.txt</div><div class="line">This is a trial of the trial script.</div><div class="line">This is the second trial of the trial script.</div><div class="line">$</div></pre></td></tr></table></figure>
<p><code>g</code>标记会替换所以匹配到的字符串.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ cat data3.txt</div><div class="line">This is a test line.</div><div class="line">This is a different line.</div><div class="line">$</div><div class="line">$ sed -n &apos;s/test/trial/p&apos; data3.txt This is a trial line.</div><div class="line">$</div></pre></td></tr></table></figure>
<p><code>p</code>标记会打印匹配到的行。通常会和<code>-n</code>选项一起使用。</p>
<p>w替换标记会产生同样的输出，不过会将输出保存到指定文件中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ sed &apos;s/test/trial/w test.txt&apos; data3.txt</div><div class="line">This is a trial line.</div><div class="line">This is a different line.</div><div class="line">$</div><div class="line">$ cat test.txt</div><div class="line">This is a trial line.</div><div class="line">$</div></pre></td></tr></table></figure>
<p><code>sed</code> 的正常输出是在<code>STDOUT</code>，只有那些匹配到的行才会保存到指定的文本文件中。</p>
<h3 id="1-2-替换字符"><a href="#1-2-替换字符" class="headerlink" title="1.2 替换字符"></a>1.2 替换字符</h3><p>有时会在字符串中遇到不太方便处理的字符，比如<code>Linux</code>下的<code>/</code>。替换路径中的<code>/</code>就比较麻烦，必须使用<code>\</code>来转义：</p>
<p><code>$ sed &#39;s/\/bin\/bash/\/bin\/csh/&#39; /etc/passwd</code></p>
<p>要解决这个问题，<code>sed</code>允许使用其它字符来作为替换命令中的字符串分隔符:</p>
<p><code>$ sed &#39;s!/bin/bash!/bin/csh!&#39; /etc/passwd</code></p>
<p>这个例子使用感叹号作为字符串分隔符，这样路径名就容易阅读和理解了。 </p>
<h2 id="2-使用地址"><a href="#2-使用地址" class="headerlink" title="2. 使用地址"></a>2. 使用地址</h2><p>默认情况下，<code>sed</code>中的命令会作用于所有的数据行，但是如果只想将命令作用于某些特定的行，则必须使用<em>行寻址(<code>line addressing</code>)</em><br><code>sed</code>中有两种行寻址:</p>
<ul>
<li>以数字形式表示行区间</li>
<li>以文本模式来过滤出行</li>
</ul>
<p>以上两种形式都使用相同的格式来制定行地址：</p>
<p><code>[address]command</code></p>
<p>也可以将特定地址的多个命令分组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">address &#123;</div><div class="line">    command1</div><div class="line">    command2</div><div class="line">    command3</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>sed</code>会将特定的命令作用于指定的行上。</p>
<h3 id="2-1-使用数字方式的行寻址"><a href="#2-1-使用数字方式的行寻址" class="headerlink" title="2.1 使用数字方式的行寻址"></a>2.1 使用数字方式的行寻址</h3><p>使用数字方式的寻找时，可以使用行在文本流中的位置来引用。文本流中第一行编号为<code>1</code>，然后按顺序分配行号。<br>在命令中使用行号时可以指定单个行号，或是用起始行号、逗号以及结尾行号指定的一定区间范围的行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ sed &apos;2s/dog/cat/&apos; data1.txt</div><div class="line">The quick brown fox jumps over the lazy dog</div><div class="line">The quick brown fox jumps over the lazy cat</div><div class="line">The quick brown fox jumps over the lazy dog</div><div class="line">The quick brown fox jumps over the lazy dog</div><div class="line">$</div></pre></td></tr></table></figure>
<p>上面的例子使用的是单个行号，<code>sed</code>只修改了第二行的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ sed &apos;2,$s/dog/cat/&apos; data1.txt</div><div class="line">The quick brown fox jumps over the lazy dog</div><div class="line">The quick brown fox jumps over the lazy cat</div><div class="line">The quick brown fox jumps over the lazy cat</div><div class="line">The quick brown fox jumps over the lazy cat</div><div class="line">$</div></pre></td></tr></table></figure>
<p>上面使用了行地址区间。并且<code>$</code>代表从某行开始的所有行。</p>
<h3 id="2-2-使用文本模式的行寻址"><a href="#2-2-使用文本模式的行寻址" class="headerlink" title="2.2 使用文本模式的行寻址"></a>2.2 使用文本模式的行寻址</h3><p><code>sed</code>编辑器允许指定文本模式来过滤出命令有要作用的行。格式如下:</p>
<p><code>/pattern/command</code></p>
<p>必须用正斜线将制定的<code>pattern</code>封起来。其实就是使用<em>正则表达式(<code>regular expression</code>)</em>来过滤文本行. 正则表达式允许创建高级文本模式来匹配各种数据。这种表达式结合了一些列通配符、特殊字符以及固定文本字符来匹配几乎任何形式的文本的简练模式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ grep Samantha /etc/passwd</div><div class="line">Samantha:x:502:502::/home/Samantha:/bin/bash</div><div class="line">$</div><div class="line">$ sed &apos;/Samantha/s/bash/csh/&apos; /etc/passwd</div><div class="line">root:x:0:0:root:/root:/bin/bash</div><div class="line">bin:x:1:1:bin:/bin:/sbin/nologin</div><div class="line">[...]</div><div class="line">Christine:x:501:501:Christine B:/home/Christine:/bin/bash</div><div class="line">Samantha:x:502:502::/home/Samantha:/bin/csh</div><div class="line">Timothy:x:503:503::/home/Timothy:/bin/bash</div><div class="line">$</div></pre></td></tr></table></figure>
<p>上面是一个使用简单的文本模式匹配的例子。关于复杂的正则表达式的内容请看相关文章。</p>
<h3 id="2-3-命令组合"><a href="#2-3-命令组合" class="headerlink" title="2.3 命令组合"></a>2.3 命令组合</h3><p>如果需要在单行上执行多条命令，可以用花括号将多条命令组合在一起。<code>sed</code>编辑器会在地址行处执行每条命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ sed &apos;2&#123;</div><div class="line">&gt; s/fox/elephant/</div><div class="line">&gt; s/dog/cat/</div><div class="line">&gt; &#125;&apos; data1.txt</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown elephant jumps over the lazy cat.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">$</div></pre></td></tr></table></figure>
<p>两条命令都会作用在第二行。当然也可以使用地址区间:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ sed &apos;3,$&#123;</div><div class="line">&gt; s/brown/green/</div><div class="line">&gt; s/lazy/active/</div><div class="line">&#125;&apos; data1.txt</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick brown fox jumps over the lazy dog.</div><div class="line">The quick green fox jumps over the active dog.</div><div class="line">The quick green fox jumps over the active dog.</div><div class="line">$</div></pre></td></tr></table></figure>
<p><code>sed</code> 会将上面的两条命令作用于第三行之后的所有行上。</p>
<h2 id="2-删除行"><a href="#2-删除行" class="headerlink" title="2 删除行"></a>2 删除行</h2><p>除了替换文本，<code>sed</code>也可以删除文本流中的特定行。<code>sed</code>得删除命令是<code>d</code>，但是使用该命令要非常小心，如果忘记在命令中加上寻址符的话，流中的文本都会被删除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ cat data1.txt</div><div class="line">The quick brown fox jumps over the lazy dog</div><div class="line">The quick brown fox jumps over the lazy dog</div><div class="line">The quick brown fox jumps over the lazy dog</div><div class="line">The quick brown fox jumps over the lazy dog</div><div class="line">$</div><div class="line">$ sed &apos;d&apos; data1.txt</div><div class="line">$</div></pre></td></tr></table></figure>
<p>当和寻址符一起使用时，<code>sed</code>才能发挥最大的功用。通过指定行号，<code>sed</code>可以从文本流中删除指定的行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ cat data6.txt</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is line number 3.</div><div class="line">This is line number 4.</div><div class="line">$</div><div class="line">$ sed &apos;3d&apos; data6.txt</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is line number 4.</div><div class="line">$</div></pre></td></tr></table></figure>
<p>也可以通过地址区间指定要删除的行区间:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ sed &apos;2,3d&apos; data6.txt</div><div class="line">This is line number 1.</div><div class="line">This is line number 4.</div><div class="line">$</div></pre></td></tr></table></figure>
<p>或者特殊的文件结尾字符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ sed &apos;3,$d&apos; data6.txt</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">$</div></pre></td></tr></table></figure>
<p><code>sed</code>的寻址符也可以使用模式匹配：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ sed &apos;/number 1/d&apos; data6.txt</div><div class="line">This is line number 2.</div><div class="line">This is line number 3.</div><div class="line">This is line number 4.</div><div class="line">$</div></pre></td></tr></table></figure>
<p>还可以使用文本匹配模式来删除某个区间的所有行。但是这么做要非常小心，第一个文本模式会”打开”行删除功能，第二个模式会”关闭”行删除功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ sed &apos;/1/,/3/d&apos; data6.txt</div><div class="line">This is line number 4.</div><div class="line">$</div></pre></td></tr></table></figure>
<p>另外你也要特别小心，<code>sed</code>只要在文本行中匹配到了开始模式，删除功能就会打开：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ cat data7.txt</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is line number 3.</div><div class="line">This is line number 4.</div><div class="line">This is line number 1 again.</div><div class="line">This is text you want to keep.</div><div class="line">This is the last line in the file.</div><div class="line">$</div><div class="line">$ sed &apos;/1/,/3/d&apos; data7.txt</div><div class="line">This is line number 4.</div><div class="line">$</div></pre></td></tr></table></figure>
<p>在第二次匹配到<code>1</code>后，行删除功能以及打开，因为没有在文本流中匹配到停止模式，所以删除功能就把剩余的行全部删除了。如果指定了开始模式，但是指定了一个无法匹配文本流中任何行的停止模式，这就会出现另外的问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sed &apos;/1/,/5/d&apos; data7.txt</div><div class="line">$</div></pre></td></tr></table></figure>
<p>因为删除功能在匹配到第一个模式的时候就打开了，但是没有匹配到第二个模式，所以整个文本流都被删除了。</p>
<h2 id="3-插入和增加文本"><a href="#3-插入和增加文本" class="headerlink" title="3. 插入和增加文本"></a>3. 插入和增加文本</h2><p>和其他编辑器类似，<code>sed</code>也可以向数据流中插入和添加文本行。</p>
<ul>
<li>i(insert): 在指定行前面增加一个新行</li>
<li>a(append): 在指定行后面增加一个新行</li>
</ul>
<p>这两个命令不能在单个命令行上使用。格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sed &apos;[address]command\</div><div class="line">new line&apos;</div></pre></td></tr></table></figure>
<p><code>new line</code>中的文本会出现在指定的位置。当使用插入命令时，文本会出现在数据流文本的前面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ echo &quot;This is a test line&quot; | sed &apos;i\This is a insert line&apos;</div><div class="line">This is a insert line</div><div class="line">This is a test line</div><div class="line">$</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ echo &quot;This is a test line&quot; | sed &apos;a\This is a append line&apos;</div><div class="line">This is a test line</div><div class="line">This is a append line</div><div class="line">$</div></pre></td></tr></table></figure>
<p>如果不指定地址，<code>sed</code>会在每行数据流文本前面或者后面增加或追加指定的文本。一般情况下我们只是希望在指定行的前面或者后面添加文本，这时候可以指定一个地址，可以使用数字或者匹配模式，但是不能使用地址区间。因为追加文本只能以行为单位，而不能追加到区间的前面或后面。<br>下面讲的例子是讲文本行添加到第<code>3</code>行前面和后面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">$ sed &apos;3i\</div><div class="line">This is an insert line.&apos; data6.txt</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is an inserted line.</div><div class="line">This is line number 3.</div><div class="line">This is line number 4.</div><div class="line">$</div><div class="line">$ sed &apos;3a\</div><div class="line">This is an appended line.&apos; data6.txt</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is line number 3.</div><div class="line">This is an appended line.</div><div class="line">This is line number 4.</div><div class="line">$</div></pre></td></tr></table></figure>
<p>如果想在文本流的开始和结束位置添加文本行，可以使用<code>1</code>和<code>$</code>来指定文本流的开始和结束，使用<code>i</code>或<code>a</code>在文本流的开始和末尾添加文本。<br>如果想一次行添加多行文本，可以在每行后面使用反斜线，直到最后以行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ sed &apos;1i\</div><div class="line">&gt; This is the first insert line.\</div><div class="line">&gt; And this is the second insert line.&apos; data6.txt</div><div class="line">This is the first insert line.</div><div class="line">And this is the second insert line.</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is line number 3.</div><div class="line">This is an appended line.</div><div class="line">This is line number 4.</div><div class="line">$</div></pre></td></tr></table></figure>
<h2 id="4-修改行"><a href="#4-修改行" class="headerlink" title="4. 修改行"></a>4. 修改行</h2><p><code>sed</code>中的<code>c</code>命令支持修改数据流中的整行文本。它跟<code>i</code>和<code>a</code>的工作机制一样，必须在命令中指定新行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ sed &apos;3c\</div><div class="line">&gt; This is a changed line.&apos; data6.txt</div><div class="line">This is line number 1.</div><div class="line">This is line number 2.</div><div class="line">This is a changed line of text.</div><div class="line">This is line number 4.</div><div class="line">$</div></pre></td></tr></table></figure>
<p><code>c</code>命令指出单地址也指出地址区间，也可以使用文本匹配。如果是地址区间，则会把地址区间中的文本变为指定的文本行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ sed &apos;/number 1/,/number 3/c\</div><div class="line">&gt; This is a new line.&apos; data6.txt</div><div class="line">This is a new line.</div><div class="line">this is line number 4.</div><div class="line">$</div></pre></td></tr></table></figure>
<p><strong>记住：<code>sed</code>是一个流编辑器。</strong></p>
<h2 id="5-转换命令"><a href="#5-转换命令" class="headerlink" title="5. 转换命令"></a>5. 转换命令</h2><p>转换(<code>transform</code>)命令(<code>y</code>)是唯一一个可以处理单个字符的<code>sed</code>命令。格式如下：</p>
<p><code>[address]y/inchars/outchars/</code></p>
<p>转换命令会对<code>inchars</code>和<code>outchars</code>值进行一对一映射。<code>inchars</code>中的第一个字符会被转换为<code>outchars</code>中的第一个字符，<code>inchars</code>中的第二个字符会被转换为<code>outchars</code>中的第二个字符，依次类推。所有如果<code>inchars</code>的长度和<code>outchars</code>长度不同，则<code>sed</code>会产生一条错误消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ sed &apos;y/123/789&apos; data8.txt</div><div class="line">This is line number 7.</div><div class="line">This is line number 8.</div><div class="line">This is line number 9.</div><div class="line">This is line number 4.</div><div class="line">This is line number 7 again.</div><div class="line">This is yet another line.</div><div class="line">This is the last line in the file.</div><div class="line">$</div></pre></td></tr></table></figure>
<p>转换命令是一个全局命令，也就是说它会在文本行中替换所有的指定字符，而不考虑它们出现的位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ echo &quot;There is 1 cat and 1 dog.&quot; sed &apos;y/123/456/&apos;</div><div class="line">There is 4 cat and 4 dog.</div><div class="line">$</div></pre></td></tr></table></figure>
<p>你无法限定只转换特定地方的特定字符，<code>sed</code>会转换所有匹配到的字符。</p>
<p><code>sed</code>基础的思维导图，可以参考下图：<br><img src="http://7xvudw.com1.z0.glb.clouddn.com/sed基础.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Linux&lt;/code&gt; 中可以使用强大的编辑器如 &lt;code&gt;vim&lt;/code&gt; 和 &lt;code&gt;emacs&lt;/code&gt; 来编辑文本文件。但有时候，我们只是需要自动的处理文本文件，而不是这些强大的交互式文本编辑器。这种时候可以使用 &lt;code&gt;Linux&lt;/code&gt; 的 &lt;code&gt;sed&lt;/code&gt; 和 &lt;code&gt;gawk&lt;/code&gt;。它们能够轻松的实现自动格式化、插入、修改或者删除文本元素。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>汇编笔记(三)</title>
    <link href="http://guopp.me/2017/01/13/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0-%E4%B8%89/"/>
    <id>http://guopp.me/2017/01/13/汇编笔记-三/</id>
    <published>2017-01-13T07:03:56.000Z</published>
    <updated>2017-01-13T07:03:56.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>汇编学习(二)</title>
    <link href="http://guopp.me/2017/01/13/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0-%E4%BA%8C/"/>
    <id>http://guopp.me/2017/01/13/汇编学习-二/</id>
    <published>2017-01-13T03:12:15.000Z</published>
    <updated>2017-01-13T03:13:42.000Z</updated>
    
    <content type="html"><![CDATA[<table>
<thead>
<tr>
<th>名称</th>
<th>解释</th>
<th>格式</th>
</tr>
</thead>
<tbody>
<tr>
<td>a(Assemble)</td>
<td>逐行汇编</td>
<td></td>
</tr>
<tr>
<td>c(Compare)</td>
<td>比较两内存块</td>
<td></td>
</tr>
<tr>
<td>d(Dump)</td>
<td>内存16进制显示</td>
<td></td>
</tr>
<tr>
<td>e(Enter)</td>
<td>修改内存字节</td>
<td></td>
</tr>
<tr>
<td>r(Register)</td>
<td>显示和修改寄存器</td>
<td></td>
</tr>
<tr>
<td>u(Unassemble)</td>
<td>反汇编 — 将内存中的机器指令翻译成汇编</td>
<td></td>
</tr>
<tr>
<td>t(Trace)</td>
<td>跟踪执行</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<a id="more"></a>
]]></content>
    
    <summary type="html">
    
      &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;th&gt;格式&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;a(Assemble)&lt;/td&gt;
&lt;td&gt;逐行汇编&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c(Compare)&lt;/td&gt;
&lt;td&gt;比较两内存块&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;d(Dump)&lt;/td&gt;
&lt;td&gt;内存16进制显示&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;e(Enter)&lt;/td&gt;
&lt;td&gt;修改内存字节&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;r(Register)&lt;/td&gt;
&lt;td&gt;显示和修改寄存器&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;u(Unassemble)&lt;/td&gt;
&lt;td&gt;反汇编 — 将内存中的机器指令翻译成汇编&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;t(Trace)&lt;/td&gt;
&lt;td&gt;跟踪执行&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>汇编学习笔记(一)</title>
    <link href="http://guopp.me/2017/01/11/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/"/>
    <id>http://guopp.me/2017/01/11/汇编学习笔记-一/</id>
    <published>2017-01-11T09:04:56.000Z</published>
    <updated>2017-01-12T07:40:30.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>因为机器码晦涩难懂，所以发明了汇编语言来编写机器程序。</li>
<li>汇编语言的主体是汇编指令。有以下 3 类指令：<ul>
<li>汇编指令： 机器码的助记符，有对应的机器码</li>
<li>伪指令：没有对应的机器码，由编译器执行，计算机并不执行</li>
<li>其他符号：如 <code>+</code> ,<code>-</code>,<code>*</code>,<code>-</code> 等，由编译器识别，没有对应的机器码</li>
</ul>
</li>
<li>汇编语言的核心是汇编指令。</li>
</ul>
<a id="more"></a>
<p>汇编语言的使用流程：</p>
<ul>
<li>程序员 + 汇编指令 —&gt; 汇编源程序 —&gt; 编译器 —&gt; 机器码 —&gt; 计算机执行。</li>
</ul>
<h4 id="cpu-执行程序流程"><a href="#cpu-执行程序流程" class="headerlink" title="cpu 执行程序流程"></a>cpu 执行程序流程</h4><ul>
<li>先由父程序把子程序装载到内存<ul>
<li>物理设备对应到逻辑内存空间</li>
<li>通过总线读取写入数据</li>
</ul>
</li>
<li>保存父程序寄存器状态</li>
<li>修改寄存器<ul>
<li>指令寄存器，数据段寄存器，栈段寄存器</li>
</ul>
</li>
<li>cpu 执行子程序</li>
</ul>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>寄存器是cpu的主要部件，程序主要是通过改变寄存器中的内容来实现对cpu的控制。</p>
<h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><ul>
<li>AX，BX，CX，DX（寄存器位数和cpu位数有关）</li>
<li>8086cpu 上的寄存器都可以分为两个独立的8位寄存器使用：<ul>
<li>AX —&gt; AH,AL</li>
<li>BX —&gt; BH,BL</li>
<li>CX —&gt; CH,CL</li>
<li>DX —&gt; DH,DL</li>
</ul>
</li>
</ul>
<h3 id="物理地址-内存地址"><a href="#物理地址-内存地址" class="headerlink" title="物理地址(内存地址)"></a>物理地址(内存地址)</h3><p>8086cpu使用两个16位地址来合成20位地址。<strong>物理地址=段地址x16+偏移地址</strong></p>
<h3 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h3><ul>
<li>CS，DS，SS，ES</li>
</ul>
<h3 id="CS-和-IP"><a href="#CS-和-IP" class="headerlink" title="CS 和 IP"></a><code>CS</code> 和 <code>IP</code></h3><ul>
<li>CS: 代码段寄存器</li>
<li>IP: 指令指针寄存器</li>
<li>在8086机中，任意时刻，cpu将 CS:IP 中的内容当作指令执行。</li>
</ul>
<h3 id="转移指令"><a href="#转移指令" class="headerlink" title="转移指令"></a>转移指令</h3><p><code>jmp</code> 段地址：偏移地址 : 使用<code>段地址</code>修改CS，使用<code>偏移地址</code>修改IP</p>
<p><code>jmp</code> 某一合法寄存器: 用寄存器中的值修改IP.</p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;因为机器码晦涩难懂，所以发明了汇编语言来编写机器程序。&lt;/li&gt;
&lt;li&gt;汇编语言的主体是汇编指令。有以下 3 类指令：&lt;ul&gt;
&lt;li&gt;汇编指令： 机器码的助记符，有对应的机器码&lt;/li&gt;
&lt;li&gt;伪指令：没有对应的机器码，由编译器执行，计算机并不执行&lt;/li&gt;
&lt;li&gt;其他符号：如 &lt;code&gt;+&lt;/code&gt; ,&lt;code&gt;-&lt;/code&gt;,&lt;code&gt;*&lt;/code&gt;,&lt;code&gt;-&lt;/code&gt; 等，由编译器识别，没有对应的机器码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;汇编语言的核心是汇编指令。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="assembly" scheme="http://guopp.me/tags/assembly/"/>
    
  </entry>
  
  <entry>
    <title>iOS-push-notification-part-four</title>
    <link href="http://guopp.me/2016/08/27/iOS-push-notification-part-four/"/>
    <id>http://guopp.me/2016/08/27/iOS-push-notification-part-four/</id>
    <published>2016-08-27T11:10:36.000Z</published>
    <updated>2016-08-27T11:15:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>每个远程通知都包含一个<code>payload</code>。<code>payload</code>包含系统要显示给用户的信息也包括你自定义的数据。<code>payload</code>的最大长度取决以什么<code>API</code>来发送它。如果使用<code>HTTP/2</code>的<code>API</code>，那么<code>payload</code>的最大长度是4096字节，如果使用传统的二进制方式，那么最大长度是2048字节。<code>APNs</code>会拒绝超过最大长度的任何通知。</p>
<a id="more"></a>
<p>每个远程通知都包含一个<code>payload</code>。<code>payload</code>包含系统要显示给用户的信息也包括你自定义的数据。<code>payload</code>的最大长度取决以什么<code>API</code>来发送它。如果使用<code>HTTP/2</code>的<code>API</code>，那么<code>payload</code>的最大长度是4096字节，如果使用传统的二进制方式，那么最大长度是2048字节。<code>APNs</code>会拒绝超过最大长度的任何通知。</p>
<h1 id="payload-key"><a href="#payload-key" class="headerlink" title="payload key"></a>payload key</h1><p>每个通知都是一个<code>JSON</code>字典对象。这个字典必须包括一个以<code>aps</code>为键的字典。<code>aps</code>字典必须包括下面一个或多个指定通知类型的属性：</p>
<ul>
<li>一个要显示给用户的<code>alert</code>消息</li>
<li>一个要在应用的<code>icon</code>上显示的数字</li>
<li>一个要播放的声音</li>
</ul>
<p>当远程通知被传递到设备时，相应的应用程序并没有在前台运行，那么系统会以<code>alert message</code>,<code>badge icon</code>，播放声音来提醒用户。而如果相应的应用程序正在前台运行，那么系统会把通知封装成<code>NSDictionary</code>传递给应用的<code>delegate</code>。</p>
<p><code>Provider</code>可以在<code>payload</code>中指定自定义的数据。但是自定义的数据必须使用<code>JSON</code>结构而且只能是原始类型：<code>dictionary</code>,<code>array</code>,<code>string</code>,<code>number</code>,<code>Boolean</code>。你不能在<code>payload</code>中包含任何用户信息和敏感数据。通知应该仅仅只是用来设置一些上下文信息或者内部标示。例如：在一个即时通信应用中，<code>payload</code>中可以包含自定义的用户对话标识符或者<code>Provider</code>发送通知时的时间戳。任何和警告消息对应的动作不应该是破坏性的–比如删除设备上的数据。</p>
<blockquote>
<p>重要：通知发送给设备是<code>尽最大努力</code>,但是并不是保证一定送达。通知并不是要发送数据给你的应用，它只是<code>通知</code>你的用户应用里有新的数据。</p>
</blockquote>
<p>下面的表格展示了<code>aps</code>中可用的键和它们期望的值。</p>
<table>
<thead>
<tr>
<th>key</th>
<th>value type</th>
<th>comment</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>alert</code></td>
<td>字符串或字典</td>
<td>如果<code>aps</code>字典中包括这个属性，系统会根据用户的设置显示一个标准的<code>alert</code>或者是<code>banner</code>。<br>你可用给这个属性设置为字符串或者是字典: <ul><li>如果是字符串，那么这个字符串会显示为警告的提示消息，并且包含两个按钮：关闭和查看。如果用户点击查看，应用会启动。</li><li>如果是字典，那么会根据字典中的属性有相应的显示。（下表中有详细解释）</li></ul></td>
</tr>
<tr>
<td><code>badge</code></td>
<td>数字</td>
<td>显示在应用<code>icon</code>上的数字。如果没有这个属性，应用<code>icon</code>上的数字不会改变。设置这个属性为<code>0</code>来移除<code>icon</code>上的<code>badge</code>。</td>
</tr>
<tr>
<td><code>sound</code></td>
<td>字符串</td>
<td>在应用的<code>bundle</code>中或者<code>Library/Sounds</code>目录中以这个作为文件名的声音会作为警告声音播放。如果声音文件不存在或者值是<code>default</code>,那么默认的声音会播放。</td>
</tr>
<tr>
<td><code>content-available</code></td>
<td>数字</td>
<td><code>aps</code>字典中包括这个键并且值是<code>1</code>,表示有新的内容。而且如果应用在后台被启动或恢复，那么<code>application:didReceiveRemoteNotification:fetchCompletionHandler:</code>方法会调用。</td>
</tr>
<tr>
<td><code>category</code></td>
<td>字符串</td>
<td>这个键值对表示你创建的自定义的动作的<code>UIMutableUserNotificationCategory</code>的标识符(<code>identifier</code>)</td>
</tr>
</tbody>
</table>
<p><code>alert</code>字典的键和期望的值</p>
<table>
<thead>
<tr>
<th>key</th>
<th>value type</th>
<th>comment</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>title</code></td>
<td><code>string</code></td>
<td>一个简短的字符串来说明通知的目的。</td>
</tr>
<tr>
<td><code>body</code></td>
<td><code>string</code></td>
<td>警告的消息</td>
</tr>
<tr>
<td><code>title-loc-key</code></td>
<td><code>string</code>或者<code>null</code></td>
<td><code>title</code>的本地化字符串，可用使用<code>%@</code>,<code>%n$@</code>来从<code>title-loc-args</code>中添加格式化字符串.</td>
</tr>
<tr>
<td><code>title-loc-args</code></td>
<td><code>array of strings</code> or <code>null</code></td>
<td>出现在<code>title-loc-key</code>中的格式化字符串</td>
</tr>
<tr>
<td><code>action-loc-key</code></td>
<td><code>string</code> or <code>null</code></td>
<td>替换标准<code>Close</code>和<code>View</code>的警告框的<code>View</code>为本地化字符串。</td>
</tr>
<tr>
<td><code>loc-key</code></td>
<td><code>string</code></td>
<td><code>alert-message</code> 的本地化字符串，可以使用<code>%@</code>,<code>%n$@</code>从<code>loc-args</code>中格式化字符串</td>
</tr>
<tr>
<td><code>loc-args</code></td>
<td><code>array of strings</code></td>
<td><code>loc-key</code>中的格式化字符串</td>
</tr>
<tr>
<td><code>launch-image</code></td>
<td><code>string</code></td>
<td>用户点击动作按钮或者滑动通知启动应用时，使用这个文件的启动图片。如果没有指定这个属性，系统会使用上次的应用快照或者<code>Info.plist</code>中<code>UILaunchImageFile</code>的图片或<code>Default.png</code>作为启动图片。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>如果你要设备一个警告消息并且有关闭和查看按钮的警告框，那么直接设置<code>alert</code>为字符串。不要设置<code>alert</code>为一个只包含<code>body</code>属性的字典。</p>
</blockquote>
<h1 id="Configuring-a-Silent-Notification"><a href="#Configuring-a-Silent-Notification" class="headerlink" title="Configuring a Silent Notification"></a>Configuring a Silent Notification</h1><p><code>aps</code>也可以包括<code>content-available</code>属性。<code>content-available</code>的值为<code>1</code>，那么这个远程通知是一个静默的通知。当一个静默的通知被传递到设备，iOS在后台唤醒你的应用，这样你的应用就可以从你的服务器获取新的数据或者在后台处理信息。用户不会从静默通知中知道有新的数据或者已经改变的信息，但是当他们下次打开应用时他们才会知道这些新的数据或者已经改变的信息。</p>
<p>对于静默的通知，要确保<code>aps</code>字典中没有<code>alert</code>,<code>sound</code>或者<code>badge</code>属性。如果不这样做，错误配置的通知可能不会被传递到后台的应用，而是直接以警告框的形式显示给用户。</p>
<h2 id="Localized-Formatted-Strings"><a href="#Localized-Formatted-Strings" class="headerlink" title="Localized Formatted Strings"></a>Localized Formatted Strings</h2><p>你可以通过两种方式显示本地化的警告信息：</p>
<ul>
<li>可以在服务器上直接发送已经做好本地化的通知给设备。这需要设备把当前的语言传送给服务器。</li>
<li>客户端应用可以在本地存储好已经翻译为多个语言的本地化字符串文件。然后使用<code>aps</code>字典中的<code>loc-key</code>和<code>loc-args</code>来根据当前设备语言本地化警告信息。然后显示给用户。</li>
</ul>
<p>下面是第二种方式的详细解释：（第一种前面几篇文章已经讨论过）<br>应用程序可以为它所支持的语言国际化所有的资源包括图片，声音，文字，然后把这些资源都放在应用程序的<code>bundle</code>的一个以语言代码和<code>.lproj</code>后缀结尾的子目录中（比如<code>fr.lproj</code>）。本地化的字符串是保存在<code>Localizable.strings</code>文件中。这个文件中的实体都是键值对，值也可以使用字符串参数格式化。当应用程序需要特定的资源时，例如一个本地化的字符串，它从用户的当前语言对应的目录中查找。例如，如果用户的当前语言是法语，那么对应的警告信息的本地化字符串就会从<code>fr.lproj</code>目录中的<code>Localizable.strings</code>文件中查找。（通过<code>NSLocalizedString</code>这个宏来请求本地化的字符串）</p>
<blockquote>
<p>注意，这也是<code>action-loc-key</code>属性所执行的步骤。它也会在<code>LocalizedString.strings</code>文件中查找对应的本地化字符串。iOS使用这个字符串来显示警告框右边的按钮的标题。(<code>action</code>按钮)</p>
</blockquote>
<p>为了清楚的说明这个步骤，让我们看看下面的例子。<code>Provider</code>提供了下面的字典作为<code>alert</code>的值:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&quot;alert&quot;: &#123;</div><div class="line">    &quot;loc-key&quot;: &quot;GAME_PLAY_REQUEST_FORMAT&quot;,</div><div class="line">    &quot;loc-args&quot;: [&quot;Jena&quot;, &quot;Frank&quot;]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当用户收到这个通知后，它使用<code>GAME_PLAY_REQUEST_FORMAT</code>这个键从相应<code>.lproj</code>目录中的<code>Localizable.strings</code>文件中查找对应的字符串值。假设当前的<code>Localizable.strings</code>文件中有一个这样的实体：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;GAME_PLAY_REQUEST_FORMAT&quot;=&quot;%@ and %@ have invited you to play Monopoly&quot;;</div></pre></td></tr></table></figure></p>
<p>设备显示<code>Jenna and Frank have invited you to play Monopoly</code>这个警告消息。</p>
<p>除了<code>%@</code>,你也可以使用<code>%n$%@</code>来用指定位置的字符串来替换格式符。<code>n</code>表示使用<code>loc-args</code>中第<code>n</code>个元素来替换（索引从<code>1</code>开始）。因此如果<code>Localizable.strings</code>文件中的实体是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;GAME_PLAY_REQUEST_FORMAT&quot; = &quot;%2$@ and %1$@ have invited you to play Monopoly&quot;;</div></pre></td></tr></table></figure></p>
<p>设备会显示<code>Frank and Jenna have invited you to play Monopoly</code>警告消息。</p>
<blockquote>
<p>注意：只有当你必须使用<code>alert</code>字典时才这样做。这些属性的值，特别是当它们是很长的字符串时，相比于性能会占用更多的带宽。很多的应用都不需要这些属性，应为消息最初都来自用户。</p>
</blockquote>
<h2 id="Examples-of-JSON-Payloads"><a href="#Examples-of-JSON-Payloads" class="headerlink" title="Examples of JSON Payloads"></a>Examples of JSON Payloads</h2><p>下面例子的通知中的<code>payload</code>都是为了说明上面表格中各种属性的使用。<code>acme</code>属性是自定义的数据。</p>
<blockquote>
<p>注意： 下面例子都是使用空格和换行符来增加可读性。但是在实践应用中要避免空格和换行，这会减小<code>payload</code>的大小，增加网络的性能。</p>
</blockquote>
<p><strong><code>Example 1</code></strong>。下面的<code>aps</code>字典中有一个简单的警报字符串和两个默认的按钮（<code>Close</code>和<code>View</code>）。这个<code>payload</code>也包含自定义的数组属性.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;aps&quot;: &#123; &quot;alert&quot;: &quot;Message received from Bob&quot; &#125;,</div><div class="line">    &quot;acme2&quot;: [ &quot;bang&quot;, &quot;whiz&quot; ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong><code>Example 2</code></strong>。在这个例子中使用<code>aps</code>字典显示了一个警告消息并且左边是<code>Close</code>按钮，右边是本地化的<code>action</code>按钮。在这个例子中<code>PLAY</code>是本地化字符串的键用来从<code>Localizable.strings</code>文件中获取对应的本地化字符串值。<code>aps</code>字典也包括应用的<code>icon</code>的<code>badge</code>数字。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;aps&quot;: &#123;</div><div class="line">        &quot;alert&quot;: &#123;</div><div class="line">            &quot;title&quot;: &quot;Game Request&quot;,</div><div class="line">            &quot;body&quot;: &quot;Bob wants to play poker&quot;,</div><div class="line">            &quot;action-loc-key&quot;: &quot;PLAY&quot;</div><div class="line">        &#125;,</div><div class="line">        &quot;badge&quot;: 5</div><div class="line">    &#125;,</div><div class="line">    &quot;acme1&quot;: &quot;bar&quot;,</div><div class="line">    &quot;acme2&quot;: [&quot;bang&quot;, &quot;whiz&quot;]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong><code>Example 3</code></strong>。这个例子指定设备要显示一个带两个按钮的警告框（<code>Close</code>和<code>View</code>）。它也会在应用程序的<code>icon</code>上显示数字<code>9</code>，而且会播放声音当警告框出现时。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;aps&quot;: &#123;</div><div class="line">        &quot;alert&quot;: &quot;You got your emails&quot;,</div><div class="line">        &quot;badge&quot;: 9,</div><div class="line">        &quot;sound&quot;: &quot;bingbong.aiff&quot;</div><div class="line">    &#125;,</div><div class="line">    &quot;acme1&quot;: &quot;bar&quot;,</div><div class="line">    &quot;acme2&quot;: 42</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong><code>Example 4</code></strong>。这个例子使用<code>loc-key</code>和<code>loc-args</code>来显示一个本地化的警告消息。它也包括自定义的警报声音和自定义的数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;aps&quot;: &#123;</div><div class="line">        &quot;alert&quot;: &#123;</div><div class="line">            &quot;loc-key&quot;: &quot;GAME_PLAY_REQUEST_FORMAT&quot;,</div><div class="line">            &quot;loc-args&quot;: [ &quot;Jenna&quot;, &quot;Frank&quot; ]</div><div class="line">        &#125;,</div><div class="line">        &quot;sound&quot;: &quot;chime.aiff&quot;</div><div class="line">    &#125;,</div><div class="line">    &quot;acme&quot;: &quot;foo&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong><code>Example 5</code></strong>。这个例子使用<code>category</code>键来指定一组通知动作.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;aps&quot;: &#123;</div><div class="line">        &quot;category&quot;: &quot;NEW_MESSAGE_CATEGORY&quot;,</div><div class="line">        &quot;alert&quot;: &#123;</div><div class="line">            &quot;body&quot;: &quot;Acme message received from Johnny Appleseed&quot;,</div><div class="line">            &quot;action-loc-key&quot;: &quot;VIEW&quot;</div><div class="line">        &#125;,</div><div class="line">        &quot;badge&quot;: 3,</div><div class="line">        &quot;sound&quot;: &quot;chime.aiff&quot;</div><div class="line">    &#125;,</div><div class="line">    &quot;acme-account&quot;: &quot;jane.applesee@apple.com&quot;,</div><div class="line">    &quot;acme-message&quot;: &quot;message123456&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每个远程通知都包含一个&lt;code&gt;payload&lt;/code&gt;。&lt;code&gt;payload&lt;/code&gt;包含系统要显示给用户的信息也包括你自定义的数据。&lt;code&gt;payload&lt;/code&gt;的最大长度取决以什么&lt;code&gt;API&lt;/code&gt;来发送它。如果使用&lt;code&gt;HTTP/2&lt;/code&gt;的&lt;code&gt;API&lt;/code&gt;，那么&lt;code&gt;payload&lt;/code&gt;的最大长度是4096字节，如果使用传统的二进制方式，那么最大长度是2048字节。&lt;code&gt;APNs&lt;/code&gt;会拒绝超过最大长度的任何通知。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS push notification part two</title>
    <link href="http://guopp.me/2016/08/27/iOS-push-notification-part-two/"/>
    <id>http://guopp.me/2016/08/27/iOS-push-notification-part-two/</id>
    <published>2016-08-27T06:44:00.000Z</published>
    <updated>2016-08-27T06:50:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>应用程序必须进行适当配置，才可以接受本地或远程通知。配置过程在<code>iOS</code>和<code>OS X</code>略有不同，但基本原理是相同的。在启动时，您的应用程序注册接收通知，并与系统配合来配置通知支持。一旦注册完成，可以开始传递给你的应用程序创建的通知。然后，您的应用程序处理这些收到的通知，并提供相应的响应。</p>
<p>在<code>IOS</code>和<code>tvOS</code>，注册通知被分成两个部分：注册所支持的用户交互和注册通知自己。注册您的应用程序支持的用户交互类型来告诉操作系统要如何通知用户当一个通知到达时。本地或远程通知都需要此步骤。对于远程通知，必须执行注册的第二步来获得<code>APNs</code>用于传送通知的应用程序特定的设备<code>token</code>。 （对于本地通知，没有第二个注册步骤。）在<code>OS X</code>中，仅支持远程通知应用程序才需要注册。</p>
<a id="more"></a>
<p>应用程序必须进行适当配置，才可以接受本地或远程通知。配置过程在<code>iOS</code>和<code>OS X</code>略有不同，但基本原理是相同的。在启动时，您的应用程序注册接收通知，并与系统配合来配置通知支持。一旦注册完成，可以开始传递给你的应用程序创建的通知。然后，您的应用程序处理这些收到的通知，并提供相应的响应。</p>
<p>在<code>IOS</code>和<code>tvOS</code>，注册通知被分成两个部分：注册所支持的用户交互和注册通知自己。注册您的应用程序支持的用户交互类型来告诉操作系统要如何通知用户当一个通知到达时。本地或远程通知都需要此步骤。对于远程通知，必须执行注册的第二步来获得<code>APNs</code>用于传送通知的应用程序特定的设备<code>token</code>。 （对于本地通知，没有第二个注册步骤。）在<code>OS X</code>中，仅支持远程通知应用程序才需要注册。</p>
<h1 id="注册通知支持的用户交互类型"><a href="#注册通知支持的用户交互类型" class="headerlink" title="注册通知支持的用户交互类型"></a>注册通知支持的用户交互类型</h1><p>在<code>iOS8</code>和更高版本的系统中，使用本地或远程通知的应用必须注册该应用程序支持的用户交互类型。应用程序可以要求图标<code>badge</code>，显示警告信息，或播放声音。当您请求这些互动类型的时候，应该先查看该用户已允许什么类型的交互。如果用户不允许某个特定类型的交互，系统将忽略尝试以这种方式与用户进行交互。例如，如果一个通知要显示警告信息，并播放声音，而用户不允许声音，系统会显示警告信息，但不播放声音。</p>
<p>要注册您的应用程序支持的交互类型，调用<code>registerUserNotificationSettings：</code>方法。使用<code>setting object</code>来指定应用程序是否<code>badge</code>图标，是否显示警告信息，或播放声音。如果你不要求任何交互类型，系统悄悄的推送所有通知到你的应用程序。下面的代码显示了支持显示警报消息，并播放声音的应用程序的代码段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">UIUserNotificationType types = (UIUserNotificationType) (UIUserNotificationTypeBadge |</div><div class="line">UIUserNotificationTypeSound | UIUserNotificationTypeAlert);</div><div class="line">UIUserNotificationSettings *mySettings = [UIUserNotificationSettings settingsForTypes:types categories:nil];</div><div class="line">[[UIApplication sharedApplication] registerUserNotificationSettings:mySettings];</div></pre></td></tr></table></figure></p>
<p>除了注册您的应用程序的交互类型，应用程序可以注册一个或多个类别。类别都支持本地和远程通知，并使用它们来标识通知的目的。你的<code>iOS</code>应用程序可以使用类别标识符来决定如何处理通知。在<code>watchOS</code>，类别也被用来定制显示给用户的通知接口。</p>
<p>从<code>iOS8</code>开始，你可以选择通过注册自定义动作的通知类型创建可以执行动作的通知。当一个可执行的通知到达时，系统会为每个注册的操作添加按钮，并添加这些按钮到通知界面。这些操作按钮是用户能够执行相关通知任务的快捷方式。例如，对于会议的远程通知邀请可能会提供动作来接受或拒绝该会议。当用户点击你的一个动作按钮，系统会通知你的应用程序，让你有机会可以执行相应的动作。</p>
<p>当应用程序第一次调用<code>registerUserNotificationSettings：</code>方法，<code>iOS</code>设备将提示用户允许指定的交互。在后续应用启动中，调用此方法不会提示用户。调用方法后，<code>iOS</code>异步的报告结果到<code>application：didRegisterUserNotificationSettings：</code>方法中。当你第一次注册你的设置，iOS在调用此方法之前等待用户的反应，但在随后的调用将返回现有的用户设置。</p>
<p>用户可以通过<code>Setting app</code>在任何时候改变你的应用程序通知设置。由于设置可以改变，始终调用<code>registerUserNotificationSettings：</code>在应用启动时，然后使用<code>application：didRegisterUserNotificationSettings：</code>方法来获得结果。如果用户不允许特定的通知类型，避免使用这些类型来配置你的应用程序的本地和远程通知。</p>
<h1 id="注册远程通知"><a href="#注册远程通知" class="headerlink" title="注册远程通知"></a>注册远程通知</h1><p>想要接收远程通知必须注册苹果推送通知服务（<code>APNs</code>）来获得一个<code>device token</code>。在<code>iOS8</code>和更高版本，注册包括以下步骤：</p>
<ol>
<li>在注册应用程序的支持的用户交互类型。</li>
<li>调用<code>registerForRemoteNotifications</code>方法来注册远程通知。 （在<code>OS X</code>中，使用<code>registerForRemoteNotificationTypes：</code>方法来注册你的应用程序支持交互类型并在同一步中注册远程通知。）</li>
<li>使用应用程序委托<code>application：didRegisterForRemoteNotificationsWithDeviceToken：</code>方法来接收提供远程通知所需要的<code>device token</code>。使用<code>application：didFailToRegisterForRemoteNotificationsWithError：</code>方法来处理错误。</li>
<li>如果注册成功，发送<code>device token</code>到用于生成远程通知的服务器</li>
</ol>
<blockquote>
<p><code>iOS</code>注意：如果蜂窝或Wi-Fi连接不可用，无论是<code>application：didRegisterForRemoteNotificationsWithDeviceToken：</code>方法或者<code>application：didFailToRegisterForRemoteNotificationsWithError：</code>方法都不会被调用。对于<code>Wi-Fi</code>连接，这有时会发生在设备不能超过配置端口连接到<code>APNs</code>。如果发生这种情况，用户可以通过连接到另一个不屏蔽所需端口的<code>Wi-Fi</code>网络，或者等<code>iPhone</code>或<code>iPad</code>的蜂窝数据服务变得可用。在这两种情况下，该设备应能够建立连接，然后委托方法被调用。</p>
</blockquote>
<p><code>device token</code>是将通知推送到到特定设备上的应用程序的关键。<code>Device token</code>可以改变，所以应用需要在每次启动时重新注册，并把接收到的<code>token</code>回传到你的服务器。如果无法更新设备<code>token</code>，远程通知可能不会被传递到设备。当用户将备份数据恢复到新设备或电脑，或重新安装操作系统时设备<code>token</code>总是会改变。当将数据迁移到新的设备或计算机，用户必须启动应用程序一次，从而远程通知可以传送到该设备。</p>
<p>永远不要缓存设备<code>token</code>;总是从系统中获得<code>token</code>。如果您的应用程序之前注册过远程通知，再调用<code>registerForRemoteNotifications</code>方法不会产生任何额外的开销，<code>iOS</code>会立即返回现有的设备<code>token</code>到应用程序委托。此外，iOS会随时调用你的委托方法当设备<code>token</code>变化的时候，而不是仅仅只在你的应用程序注册或重新注册远程通知的时候。</p>
<p>下面的代卖显示了如何在<code>iOS</code>应用中注册远程通知。应用程序注册支持的动作类型后，下面的方法调用<code>registerForRemoteNotifications</code>方法。在接收到设备<code>token</code>后，委托方法调用自定义代码来发送<code>token</code>到服务器。在<code>OS X</code>中，注册交互类型的方法是不同的，但是用于处理注册的委托方法是类似的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">- (void)applicationDidFinishLaunching:(UIApplication *)app &#123;</div><div class="line">    </div><div class="line">    UIUserNotificationType types = UIUserNotificationTypeBadge |  </div><div class="line">    UIUserNotificationTypeSound | UIUserNotificationTypeAlert; </div><div class="line">    UIUserNotificationSettings *mySettings = [UIUserNotificationSettings</div><div class="line">    settingsForTypes:types categories:nil]; [[UIApplication sharedApplication]</div><div class="line">    registerUserNotificationSettings:mySettings];</div><div class="line">    </div><div class="line">    // Register for remote notifications. </div><div class="line">    [[UIApplication sharedApplication] registerForRemoteNotifications];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Handle remote notification registration. </div><div class="line">- (void)application:(UIApplication *)app didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)devToken &#123; </div><div class="line"></div><div class="line">    const void *devTokenBytes = [devToken bytes];</div><div class="line">    self.registered = YES; [self sendProviderDeviceToken:devTokenBytes]; // custom method</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)application:(UIApplication *)app didFailToRegisterForRemoteNotificationsWithError:(NSError *)err &#123; </div><div class="line"></div><div class="line">    NSLog(@&quot;Error in registration. Error: %@&quot;, err); </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在<code>application︰ didFailToRegisterForRemoteNotificationsWithError︰</code>方法中，你应该适当地处理错误对象和禁用与远程通知相关的任何功能。因为通知无论如何都不会被送达，这简直不能更棒，因为不需要处理和显示这些通知。</p>
<h1 id="注册可以执行动作的通知类型"><a href="#注册可以执行动作的通知类型" class="headerlink" title="注册可以执行动作的通知类型"></a>注册可以执行动作的通知类型</h1><p>可以执行动作的通知可以让你在标准的本地和远程通知界面上添加自定义的动作按钮。可动作的通知给用户一种快速且简单的方式执行和通知相关的任务来响应通知。在<code>iOS8</code>之前，通知只有一种默认的动作。在<code>iOS8</code>之后，在锁屏界面，在通知中心的通知横幅和通知条目上都可以有一个或两个自定义的动作按钮。<code>modal alert</code> 甚至能显示四个按钮。当用户点击了其中的自定义按钮，<code>iOS</code>会通知你的应用来让你执行该按钮相关的任务。</p>
<blockquote>
<p>注意：<code>OS X</code> 并没有这种可以执行动作的通知。</p>
</blockquote>
<h2 id="定义你的可执行动作的通知"><a href="#定义你的可执行动作的通知" class="headerlink" title="定义你的可执行动作的通知"></a>定义你的可执行动作的通知</h2><p>自定义动作的配置取决于定义一个或多个类别的通知。每个类别代表应用会收到的一种类型的通知，你必须定义你的应用所支持的类别。对于每个类别中，可以定义收到该类型的通知时，用户可能采取的动作。然后，使用iOS的<code>registerUserNotificationSettings</code>注册类别，动作和应用支持的交互类型。</p>
<p>每个自定义动作包括按钮标题和iOS要显示给用户的信息当用户选择该按钮时。通过创建UIMutableUserNotificationAction类的实例并适当配置其属性来产生一个动作。下面的代码创建一个单一的“accept”动作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">UIMutableUserNotificationAction *acceptAction = [[UIMutableUserNotificationAction alloc] init];</div><div class="line">// The identifier that you use internally to handle the action. acceptAction.identifier = @&quot;ACCEPT_IDENTIFIER&quot;;</div><div class="line"></div><div class="line">// The localized title of the action button. </div><div class="line">acceptAction.title = @&quot;Accept&quot;;</div><div class="line"></div><div class="line">// Specifies whether the app must be in the foreground to perform the action. acceptAction.activationMode = UIUserNotificationActivationModeBackground;</div><div class="line"></div><div class="line">// Destructive actions are highlighted appropriately to indicate their nature. acceptAction.destructive = NO;</div><div class="line"></div><div class="line">// Indicates whether user authentication is required to perform the action. acceptAction.authenticationRequired = NO;</div></pre></td></tr></table></figure></p>
<p>创建任何自定义操作对象后，分配这些对象到<code>UIUserNotificationCategory</code>用于定义你的应用的通知类别。如果在启动时配置通知类别，通常创建<code>UIMutableUserNotificationCategory</code>类的一个实例。分配类别标识符到新的实例并使用<code>setActions：forContext：</code>方法来与该类别的自定义动作联系起来。上下文参数，可以让你对不同的系统界面制定不同的动作。默认的上下文情况支持在<code>modal alert</code>时显示四个动作。最小的<code>context</code>只支持两个动作，在锁屏界面，通知横幅，和通知中心中。</p>
<p>下面的例子显示了一个邀请的类别，其中包括来自上面代码中的<code>accept</code>按钮和两个额外的动作。在这个例子中，最小的上下文仅显示接受和拒绝按钮。如果没有指定最小上下文的动作，那么最前面的两个按钮就会被显示。按钮的顺序决定了它们在屏幕上显示的顺序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// First create the category </div><div class="line">UIMutableUserNotificationCategory *inviteCategory = [[UIMutableUserNotificationCategory alloc] init];</div><div class="line"></div><div class="line">// Identifier to include in your push payload and local notification</div><div class="line">inviteCategory.identifier = @&quot;INVITE_CATEGORY&quot;;</div><div class="line"></div><div class="line">// Set the actions to display in the default context </div><div class="line">[inviteCategory setActions:@[acceptAction, maybeAction, declineAction] forContext:UIUserNotificationActionContextDefault];</div><div class="line"></div><div class="line">// Set the actions to display in a minimal context</div><div class="line">[inviteCategory setActions:@[acceptAction, declineAction] forContext:UIUserNotificationActionContextMinimal];</div></pre></td></tr></table></figure></p>
<p>创建完通知动作类别后必须注册这些类别。应用可以注册任意数量的类别，但是每个列别必须是唯一的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSSet *categories = [NSSet setWithObjects:inviteCategory, alarmCategory, ...</div><div class="line"></div><div class="line">UIUserNotificationSettings *settings = [UIUserNotificationSettings settingsForTypes:types categories:categories];</div><div class="line">[[UIApplication sharedApplication] registerUserNotificationSettings:settings];</div></pre></td></tr></table></figure></p>
<p>通知的类型和动作的类别都是使用<code>UIUserNotificationSettings</code>的类方法<code>settingsForTypes:categories:</code>来注册，只是一个的<code>categories</code>参数为<code>nil</code>。</p>
<h2 id="触发可动作的通知"><a href="#触发可动作的通知" class="headerlink" title="触发可动作的通知"></a>触发可动作的通知</h2><p>为了显示你定义好的可动作的通知，你必须推送一个远程通知或者触发一个本地通知。在远程通知的情况下你必须在payload中包括类别的标识符（Code2-1）。对类别的支持是你的应用程序和推送服务器之间的合作完成的。当你的服务器想推送一个通知给用户，它可以在payload中添加合适的类别值。如果iOS得到一个有类别值的推送通知，它会在应用中搜索注册过的有一样值的类别，如果找到匹配的就会显示响应的动作按钮。</p>
<p>推送的payload的大小被HTTP/2提供的API限制，在2015年12月是4KB。(在2014年，Apple在遗留的二进制接口中把payload的大小限制从256字节提高到2KB)<br>Code2-1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;aps&quot;: &#123;</div><div class="line">        &quot;alert&quot;: &quot;You&apos;re invited!&quot;,</div><div class="line">        &quot;category&quot;: &quot;INVITE_CATEGORY&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在本地通知的情况下，你像平常一样创建通知，设置动作类别，然后触发通知。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">UILocalNotification *notification = [[UILocalNotification alloc] init]; </div><div class="line">. . . </div><div class="line">notification.category = @&quot;INVITE_CATEGORY&quot;; </div><div class="line">[[UIApplication sharedApplication] scheduleLocalNotification:notification];</div></pre></td></tr></table></figure></p>
<h2 id="处理可动作通知"><a href="#处理可动作通知" class="headerlink" title="处理可动作通知"></a>处理可动作通知</h2><p>如果你的应用不是在前台运行，当用户滑动或者点击通知时，<code>iOS</code>会在前台启动你的应用然后调用<code>application:didFinishLaunchingWithOptions:</code>并在<code>options</code>字典中包括本地或远程通知。在远程通知的情况下，系统还会调用<code>application:didReceiveRemoteNotification:fetchCompletionHandler:</code>。</p>
<p>如果你的应用已经在前台，<code>iOS</code>就不会显示这个通知。相反，<code>iOS</code>会调用<code>application:didReceiveLocalNotification:</code>或者<code>application:didReceiveRemoteNotification:fetchCompletionHandler:</code>。（如果你没有实现<code>application:didReceiveRemoteNotification:fetchCompletionHandler:</code>,iOS会调用<code>application:didReceiveRemoteNotification:</code>）</p>
<p>最后，为了能在<code>iOS8</code>或之后的系统里处理自定义动作，你必须实现下面两个方法中的至少一个：<code>application:handleActionWithIdentifier:forRemoteNotification:completionHandler:</code>,<code>application:handleActionWithIdentifier:forLocalNotification:completionHandler:</code>。这两张情况下你都能得到动作标识符，可以用它来确定用户点击的哪个动作。你也会得到本地或远程通知，你可以用它来获得任何关于这个动作的信息。最后系统会传递给你一个<code>completion handler</code>,当你处理完这个动作之后你必须调用这个<code>handler</code>。下面代码显示了一个自定义动作处理的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (void)application:(UIApplication *) application </div><div class="line">    handleActionWithIdentifier: (NSString *) identifier </div><div class="line">    // either forLocalNotification: (NSDictionary *) notification or</div><div class="line">    forRemoteNotification: (NSDictionary *) notification </div><div class="line">    completionHandler: (void (^)()) completionHandler &#123;</div><div class="line">    </div><div class="line">     if ([identifier isEqualToString: @&quot;ACCEPT_IDENTIFIER&quot;]) &#123;</div><div class="line">        </div><div class="line">        [self handleAcceptActionWithNotification:notification]; </div><div class="line">    &#125;</div><div class="line">        </div><div class="line">    // Must be called when finished </div><div class="line">    completionHandler();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="触发本地通知"><a href="#触发本地通知" class="headerlink" title="触发本地通知"></a>触发本地通知</h1><p>在<code>iOS</code>中,你创建一个<code>UILocalNotification</code>的实例然后使用<code>UIApplication</code>的<code>scheduleLocalNotification:</code>方法来设置通知的触发。在<code>OS X</code>中，你创建一个<code>NSUserNotification</code>的实例，然后<code>NSUserNotificationCenter</code>负责设置传递它。（<code>OS X</code>应用也可以实现<code>NSUserNotificationCenterDelegate</code>协议来自定义<code>NSUserNotificationCenter</code>的行为。）</p>
<p>在iOS中创建和触发本地通知需要你执行以下步骤：</p>
<ol>
<li>在iOS8或更高的系统版本中，需要注册通知类型。（在OS X和早期的iOS版本中，你只需要为远程通知注册通知类型）。如果你已经注册了通知类型，则可以使用<code>currentUserNotificationSettings</code>来获取用户在应用中接受的通知类型。</li>
<li>创建一个<code>UILocalNotification</code>实例。</li>
<li>设置一个系统触发通知的日期和时间。这就是<code>fireDate</code>属性。<br>如果你设置<code>timeZone</code>属性为当前语言环境的<code>NSTimeZone</code>实例，那么系统会自定调整触发时间当设备进入到不同的时区。<br>你也可以设置固定时间间隔来触发本地通知（每日，每周，每月，等等）</li>
<li>适当的配置<code>alert</code>,<code>icon badge</code>,<code>sound</code>。这样系统触发通知时就会使用这些配置来展示通知的界面。<ul>
<li><code>alert</code>有<code>message</code>，动作按钮的<code>title</code>，和<code>slider</code>(<code>alertAction</code>)属性。给它们指定一个本地化的字符串值。如果通知可以在<code>Apple Watch</code>上显示，也给<code>alertTitle</code>属性设置一个值。</li>
<li>使用<code>applicationIconBadgeNumber</code>属性来给应用的图标上设置一个<code>badge number</code>.</li>
<li>给<code>soundName</code>属性设置值来播放声音。你可以直接设置应用程序的资源包中的一个非本地化的文件名来设置属性值，也可以使用<code>UILocalNotificationDefaultSoundName</code>来获得默认的系统声音。播放声音应该和其他两种中至少一种同时作用，而不应该仅仅只是单独播放声音。</li>
</ul>
</li>
<li>另外你也可以使用<code>userInfo</code>属性为通知添加自定义的数据。例如：当一个<code>CloudKit</code>记录更改后所触发的通知中就包括这条纪录的标识符，因此<code>handler</code>就能够得到这条纪录并更新它。</li>
<li>另外在iOS8之后的系统中，本地通知也可以使用自定义可动作的通知，因此你的应用可以执行相应的动作来响应用户交互。</li>
<li>安排本地通知的交付给系统。<br>使用<code>scheduleLocalNotification:</code>来交付通知给系统。系统使用<code>UILocalNotification</code>实例中的<code>fire date</code>来触发通知。或者你也可以使用<code>presentLocalNotificationNow:</code>来立即触发这个通知。</li>
</ol>
<p>下面的代码模拟一个<code>to-do list</code>的应用在待办事件即将到来前通知用户。有几个地方需要注意，<code>alertBody</code>,<code>alertAction</code>,<code>alertTitle</code>属性都是主<code>bundle</code>中的本地化字符串。它也在<code>userInfo</code>属性中添加了待办事项的名字。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">- (void)scheduleNotificationWithItem:(ToDoItem *)item interval:(int)minutesBefore &#123;</div><div class="line"></div><div class="line">    NSCalendar *calendar = [NSCalendar autoupdatingCurrentCalendar]; </div><div class="line">    NSDateComponents *dateComps = [[NSDateComponents alloc] init]; </div><div class="line">    [dateComps setDay:item.day]; </div><div class="line">    [dateComps setMonth:item.month]; </div><div class="line">    [dateComps setYear:item.year]; </div><div class="line">    [dateComps setHour:item.hour]; </div><div class="line">    [dateComps setMinute:item.minute]; </div><div class="line">    NSDate *itemDate = [calendar dateFromComponents:dateComps];</div><div class="line"></div><div class="line">    UILocalNotification *localNotif = [[UILocalNotification alloc] init]; </div><div class="line">    if (localNotif == nil)</div><div class="line">        return; </div><div class="line">     localNotif.fireDate = [itemDate dateByAddingTimeIntervalInterval:- (minutesBefore*60)]; </div><div class="line">     localNotif.timeZone = [NSTimeZone defaultTimeZone];</div><div class="line"></div><div class="line">    localNotif.alertBody = [NSString stringWithFormat:NSLocalizedString(@&quot;%@ in %i minutes.&quot;, nil), item.eventName, minutesBefore]; </div><div class="line">    localNotif.alertAction = NSLocalizedString(@&quot;View Details&quot;, nil);</div><div class="line"></div><div class="line">    localNotif.alertTitle = NSLocalizedString(@&quot;Item Due&quot;, nil);</div><div class="line"></div><div class="line">    localNotif.soundName = UILocalNotificationDefaultSoundName;</div><div class="line"></div><div class="line">    localNotif.applicationIconBadgeNumber = 1;</div><div class="line"></div><div class="line">    NSDictionary *infoDict = [NSDictionary dictionaryWithObject:item.eventName forKey:ToDoItemKey]; </div><div class="line">    localNotif.userInfo = infoDict;</div><div class="line"></div><div class="line">    [[UIApplication sharedApplication] scheduleLocalNotification:localNotif];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>你可以通过调用<code>cancelLocalNotification</code>来取消特定的通知，也可以使用<code>cancelAllLocalNotifications</code>来取消所以的本地通知。这两张手动取消通知的方法都会关闭正在显示的通知。</p>
<p>应用也会发现本地通知非常有用当它们在后台运行的时候，当有用户感兴趣的新消息，数据和其他的一些东西出现时。这种情况下，应用可以使用<code>presentLocalNotificationNow:</code>来立即触发一个本地通知。（<code>iOS</code>允许应用在后台允许一小段时间）</p>
<h1 id="处理本地和远程通知"><a href="#处理本地和远程通知" class="headerlink" title="处理本地和远程通知"></a>处理本地和远程通知</h1><p><strong>当通知被交付时而应用不再前台运行时</strong>。这种情况下，系统显示这个通知，显示一个<code>alert</code>，<code>badge app icon</code>，或者播放一个声音，显示一个或多个动作按钮让用户点击。</p>
<p><strong>用户点击iOS8系统通知中一个动作按钮</strong>。这种情况下，iOS调用<code>application:handleActionWithIdentifier:forRemoteNotification:completionHandler:</code>或者<code>application:handleActionWithIdentifier:forLocalNotification:completionHandler:</code>。在上面两种情况下，你都能得到按钮的标识符以此来判断用户点击的哪个按钮。你也可以得到本地或者远程的通知，来获取你需要的数据。</p>
<p><strong>用户点击了默认的动作按钮或者点击了应用的图片</strong>。如果默认的动作按钮被用户点击，系统会启动应用程序然后调用<code>application:didFinishLaunchingWithOptions:</code>传入通知的<code>payload</code>或者本地通知对象。虽然<code>application:didFinishLaunchingWithOptions:</code>这个方法里不是处理通知的最佳时机，但是在这里获取通知的<code>payload</code>可以让你有机会在<code>handler</code>方法调用之前开始处理和通知相关的操作。</p>
<p>对于远程通知，系统也会调用<code>application:didReceiveRemoteNotification:fetchCompletionHandler:</code></p>
<p>如果在OS X上用户点击了应用图标，应用会调用<code>applicationDidFinishLaunching:</code>方法，然后应用代理可以获得远程通知。如果在iOS上点击应用图标，应用也会调用相同的方法，但是并不能获取通知内容。</p>
<p><strong>当通知被交付时应用程序在前台运行</strong>。应用会调用<code>application:didReceiveRemoteNotification:fetchCompletionHandler:</code>或者<code>application:didReceiveLocalNotification:</code>。（如果<code>application:didReceiveRemoteNotification:fetchCompletionHandler:</code>方法没有实现，系统会调用<code>application:didReceiveRemoteNotification:</code>这个方法）.在OS X中，系统会调用<code>application:didReceiveRemoteNotification:</code>方法。</p>
<p>应用程序可以使用传入的远程通知的<code>payload</code>或者在iOS中使用<code>UILocalNotification</code>的实例来帮助设置上下文处理通知相关的操作。在理想的情况下，应用代理在不同的平台执行下面的操作来传递远程和本地通知：</p>
<ul>
<li>对于OS X，应用代理会遵循<code>NSApplicationDelegate</code>协议，实现<code>application:didReceiveRemoteNotification:</code>方法</li>
<li>对于iOS，应用代理会遵循<code>UIApplicationDelegate</code>代理，实现<code>application:didReceiveRemoteNotification:fetchCompletionHandler:</code>或者<code>application:didReceiveLocalNotification:</code>方法。为了响应通知动作，实现<code>application:handleActionWithIdentifier:forLocalNotification:completionHandler:</code>或者<code>application:handleActionWithIdentifier:forRemoteNotification:completionHandler:</code></li>
</ul>
<p>下面的代码实现了<code>application:didFinishLaunchingWithOptions:</code>方法来处理本地通知。它从<code>options</code>字典中使用<code>UIApplicationLaunchOptionsLocalNotificationKey</code>键得到了一个<code>UILocalNotification</code>的实例。从<code>UILocalNotification</code>实例的<code>userInfo</code>字典中访问到<code>to-do</code>事项并设置应用的初始上下文。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (BOOL)application:(UIApplication *)app didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; </div><div class="line">    UILocalNotification *localNotif = [launchOptions objectForKey:UIApplicationLaunchOptionsLocalNotificationKey];</div><div class="line"></div><div class="line">    if (localNotif) &#123; </div><div class="line">    NSString *itemName = [localNotif.userInfo objectForKey:ToDoItemKey];</div><div class="line">    </div><div class="line">    [viewController displayItem:itemName]; // custom method</div><div class="line">    app.applicationIconBadgeNumber = localNotif.applicationIconBadgeNumber-1;</div><div class="line"></div><div class="line">    &#125; </div><div class="line">    [window addSubview:viewController.view]; </div><div class="line">    [window makeKeyAndVisible]; </div><div class="line">    return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>远程通知的实现也是类似的，除了你必须在每个平台定义一个常量作为键来访问通知的<code>payload</code>以外：</p>
<ul>
<li>在iOS中，在应用代理的<code>application:didFinishLaunchingWithOptions:</code>方法中使用<code>UIApplicationLaunchOptionsRemoteNotificationKey</code>键来获取<code>options</code>字典中的通知的<code>payload</code>。</li>
<li>在OS X中，在应用代理的<code>applicationDidFinishLaunching:</code>方法中使用<code>NSApplicationLaunchUserNotificationKey</code>键从传入的<code>NSNotification</code>对象的<code>userInfo</code>属性中获取<code>payload</code>字典。</li>
</ul>
<p><code>payload</code>是一个字典包含通知的<code>alert</code>消息，<code>badge number</code>,和声音等等。它也能包含应用程序用来设置初始的用户界面时的自定义数据。</p>
<blockquote>
<p>重要提示：远程通知的交付没有保证，所以你不应该使用通知来传递敏感数据或不能用其他方式获得得数据。</p>
</blockquote>
<p>当在应用代理的方法中处理远程通知时，应用代理会执行额外的任务。在应用启动后，代理应该和服务器连接然后下载数据。</p>
<blockquote>
<p>注意：客户端应用应该总是和服务器异步或者在次要线程通信。</p>
</blockquote>
<p>下面的代码显示了应用在前台运行时<code>application:didReceiveLocalNotification:</code>方法的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (void)application:(UIApplication *)app didReceiveLocalNotification: (UILocalNotification *)notif &#123;</div><div class="line"></div><div class="line">    NSString *itemName = [notif.userInfo objectForKey:ToDoItemKey]; </div><div class="line">    [viewController displayItem:itemName]; // custom method </div><div class="line">    app.applicationIconBadgeNumber = notification.applicationIconBadgeNumber - 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果你想在应用在前台运行时获取远程通知，你应该实现<code>application:didReceiveRemoteNotification:fetchCompletionHandler:</code>方法。</p>
<h1 id="触发基于位置的本地通知"><a href="#触发基于位置的本地通知" class="headerlink" title="触发基于位置的本地通知"></a>触发基于位置的本地通知</h1><p>在<code>iOS8</code>和之后的系统中，可以创建基于地理位置的本地通知。当用户到达特定的地理位置区域时可以触发本地通知。<code>UILocalNotification</code>对象可以用一个<code>Core Location region</code>实例来配置。当用户进入或者离开时会触发相应的本地通知。你可以配置只触发一次或者在用户每次进入或离开时都触发本地通知。</p>
<h2 id="注册基于位置的本地通知"><a href="#注册基于位置的本地通知" class="headerlink" title="注册基于位置的本地通知"></a>注册基于位置的本地通知</h2><p>基于地理位置的本地通知需要应用支持<code>Core Location</code>。你必须配置一个<code>CLLocationManager</code>和对应的代理，然后向用户请求定位服务。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">CLLocationManager *locMan = [[CLLocationManager alloc] init]; </div><div class="line">// Set a delegate that receives callbacks that specify if your app is allowed to track the user&apos;s location </div><div class="line">locMan.delegate = self;</div><div class="line"></div><div class="line">// Request authorization to track the user’s location and enable location-based local notifications </div><div class="line">[locMan requestWhenInUseAuthorization];</div></pre></td></tr></table></figure></p>
<p>当你第一次申请定位服务时，<code>iOS</code>会请求用户同意或者拒绝应用的定位服务。<code>iOS</code>会使用<code>Info.plist</code>文件中<code>NSLocationWhenInUseUsageDescription</code>键所对应的文本来显示说明文字。如果要启动定位服务一定要包含这个键，否则<code>iOS</code>不会启动定位服务。</p>
<p>当应用在后台或者被挂起时，用户可能也可以看到基于地理位置的本地通知。然而，应用并不会收到任何回调，直到用户与<code>alert</code>交互应用才被允许获取用户的位置。</p>
<h2 id="处理地理位置回调"><a href="#处理地理位置回调" class="headerlink" title="处理地理位置回调"></a>处理地理位置回调</h2><p>在应用启动时，你应该检查位置通知的授权状态以此开启或者关闭位置通知。你必须处理的从<code>Core Location</code>返回的代理回调是<code>locationManager:didChangeAuthorizationStatus:</code>，这个方法里面会告诉你授权的状态。首先，通过回调中<code>kCLAuthorizationStatusAuthorizedWhenInUse</code>检查授权状态－－这意味着你的应用被允许来跟踪用户的位置。然后你就可以开始安排你的本地通知了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (void)locationManager:(CLLocationManager *)manager didChangeAuthorizationStatus:(CLAuthorizationStatus)status &#123;</div><div class="line"></div><div class="line">    // Check status to see if the app is authorized </div><div class="line">    BOOL canUseLocationNotifications = (status ==  </div><div class="line">    kCLAuthorizationStatusAuthorizedWhenInUse);</div><div class="line"></div><div class="line">    if (canUseLocationNotifications) &#123;</div><div class="line"></div><div class="line">        [self startShowingLocationNotifications]; // Custom method defined below </div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面的代码展示了如何创建一个基于地理位置的通知。就像普通的本地通知一样，你首先得创建一个<code>UILocalNotification</code>对象然后设置它的类型，这个例子中是一个<code>alert</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (void)startShowingNotifications &#123;</div><div class="line"></div><div class="line">    UILocalNotification *locNotification = [[UILocalNotification alloc] init];</div><div class="line">    locNotification.alertBody = @“You have arrived!”;</div><div class="line">    locNotification.regionTriggersOnce = YES;</div><div class="line"></div><div class="line">    locNotification.region = [[CLCircularRegion alloc] initWithCenter:LOC_COORDINATE          radius:LOC_RADIUS </div><div class="line">    identifier:LOC_IDENTIFIER];</div><div class="line"></div><div class="line">    [[UIApplication sharedApplication] scheduleLocalNotification:locNotification];</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>假设应用不在前台运行当用户到达上面代码指定的区域时，iOS会显示一个警告:”你已经到了”。下面一行指定当用户进入或离开此区域时警报只在第一次显示。这是默认的行为。但是如果对于应用来说必须每次都显示，就可以把它设置为<code>NO</code>。</p>
<p>然后，你创建了一个<code>CLCircularRegion</code>对象，并把它设置到<code>UILocalNotification</code>对象的<code>origin</code>属性。这个例子中我们使用了<code>CLCircularRegion</code>但是你也可以使用<code>CLBeaconRegion</code>或者任何<code>CLRegion</code>的子类。</p>
<p>最后，在<code>UIApplication</code>上调用<code>scheduleLocalNotification</code>来派发这个通知。</p>
<h2 id="处理基于位置的通知"><a href="#处理基于位置的通知" class="headerlink" title="处理基于位置的通知"></a>处理基于位置的通知</h2><p>假设应用被挂起时用户进入了上面指定的位置，一个显示”你来了”的警报会显示出来。你可以在<code>application:didFinishLaunchingWithOptions:</code>方法里面处理本地通知，或者当用户进入指定的区域时你的应用在前台运行，你的应用代理会收到<code>application:didReceiveLocalNotification:</code>消息。</p>
<p>处理位置通知的逻辑对于<code>application:didFinishLaunchingWithOptions:</code>和<code>application:didReceiveLocalNotification:</code>非常相似。这两个方法都会提供一个有<code>origin</code>属性的本地通知，如果<code>origin</code>属性不为<code>nil</code>，那么这就是一个位置通知。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (void)application:(UIApplication *)application didReceiveLocalNotification: (UILocalNotification *)notification &#123;</div><div class="line"></div><div class="line">    CLRegion *region = notification.region;</div><div class="line">    if (region) &#123;</div><div class="line"></div><div class="line">        [self tellFriendsUserArrivedAtRegion:region]; </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后，请记住当用户取消应用的定位授权时<code>application:didReceiveLocalNotification:</code>方法不会被调用。</p>
<h1 id="准备自定义的警报声音"><a href="#准备自定义的警报声音" class="headerlink" title="准备自定义的警报声音"></a>准备自定义的警报声音</h1><p>对于iOS中的远程通知，你可以指定自定义的声音当iOS显示本地或远程通知时播放这个声音。声音文件可以在应用的主<code>bundle</code>中，也可以在应用的数据容器的<code>Library/Sound</code>文件夹中。<br>自定义的声音由iOS的音频硬件播放出来，所以必须是下面的格式：</p>
<ul>
<li><strong><code>Linear PCM</code></strong></li>
<li><strong><code>MA4(IMA/IDPCM)</code></strong></li>
<li><strong><code>μLaw</code></strong></li>
<li><strong><code>aLaw</code></strong></li>
</ul>
<p>你可以使用<code>aiff</code>,<code>wav</code>,<code>caf</code>打包声音文件。然后在<code>Xcode</code>中添加这些声音文件到<code>bundle</code>或者到<code>Library/Sound</code>目录。</p>
<p>你可以使用<code>afconvert</code>来转换不同的音频文件。例如，可以使用下面的命令来把<code>16</code>位的<code>linear PCM</code>的系统声音<code>Submarine.aiff</code>转化为<code>CAF</code>文件格式的<code>IMA4</code>音频：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">afconvert /System/Library/Sounds/Submarine.aiff ~/Desktop/sub.caf -d ima4 -f caff -v</div></pre></td></tr></table></figure></p>
<p>可以通知把声音文件在<code>Quick Player</code>中打开然后使用<code>Show Movie Inspector</code>来检查音频的格式。</p>
<p>自定义的声音不能超过30s，如果超过这个限制，iOS不会使用这个音频文件而使用默认的系统声音来播放。</p>
<h1 id="传给服务器当前设备的语言选项"><a href="#传给服务器当前设备的语言选项" class="headerlink" title="传给服务器当前设备的语言选项"></a>传给服务器当前设备的语言选项</h1><p>如果应用程序不使用远程通知的<code>aps</code>字典中的<code>loc-key</code>和<code>loc-args</code>来获取本地化的警告消息，那么服务器需要提前本地化通知中的警报消息。要做到这一点，服务器需要知道设备的当前语言选项。然后应用需要传给服务器一个当前语言的标示，如<code>en</code>或者<code>fr</code>。</p>
<p>下面的代码展示了如何获取当前的语言并回穿给服务器。在iOS中，<code>NSLocale</code>的<code>preferredLanguages</code>属性一个只包含一个对象的数组：一个<code>NSString</code>对象表示当前的语言选项。<code>UTF8String</code>使用<code>utf-8</code>编码把该字符串转换成<code>c</code>字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSString *preferredLang = [[NSLocale preferredLanguages] objectAtIndex:0]; </div><div class="line">const char *langStr = [preferredLang UTF8String];</div><div class="line">[self sendProviderCurrentLanguage:langStr]; // custom method </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>应用需要在用户每次改变语言设置时都把语言选项发送给服务器。通过监听<code>NSCurrentLocaleDidChangeNotification</code>通知然后在回调中得到语言标示然后传给服务器，可以做到这一点。</p>
<p>如果设备的语言并不是应用支持的语言，服务器需要一种广泛使用的语言来本地化警告消息文本，如英语或西班牙语。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;应用程序必须进行适当配置，才可以接受本地或远程通知。配置过程在&lt;code&gt;iOS&lt;/code&gt;和&lt;code&gt;OS X&lt;/code&gt;略有不同，但基本原理是相同的。在启动时，您的应用程序注册接收通知，并与系统配合来配置通知支持。一旦注册完成，可以开始传递给你的应用程序创建的通知。然后，您的应用程序处理这些收到的通知，并提供相应的响应。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;IOS&lt;/code&gt;和&lt;code&gt;tvOS&lt;/code&gt;，注册通知被分成两个部分：注册所支持的用户交互和注册通知自己。注册您的应用程序支持的用户交互类型来告诉操作系统要如何通知用户当一个通知到达时。本地或远程通知都需要此步骤。对于远程通知，必须执行注册的第二步来获得&lt;code&gt;APNs&lt;/code&gt;用于传送通知的应用程序特定的设备&lt;code&gt;token&lt;/code&gt;。 （对于本地通知，没有第二个注册步骤。）在&lt;code&gt;OS X&lt;/code&gt;中，仅支持远程通知应用程序才需要注册。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS push notification part one</title>
    <link href="http://guopp.me/2016/08/27/iOS-push-notification-part-one/"/>
    <id>http://guopp.me/2016/08/27/iOS-push-notification-part-one/</id>
    <published>2016-08-27T06:37:24.000Z</published>
    <updated>2016-08-27T06:49:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>本地通知和远程通知是用户通知(<code>user notification</code>)的两种类型，它们不同于广播通知（由<code>NSNotificationCenter</code>类管理）和键值观察通知(<code>key - value obverse</code> )。即使<code>app</code>没有在前台运行，用户通知也能让用户知道有关于他们的新消息。该信息可以是简单的一条关于用户的消息，或者是即将发生的日程表事件，或者是远程服务器上新的数据。当操作系统呈现用户通知时，无论是来自本地的还是远程的通知，它们的展现形式都是一样的。他们可以显示警告信息，也可以在应用图标上显示<code>badge</code>，或者同时播放声音。</p>
<a id="more"></a>
<p>本地通知和远程通知是用户通知(<code>user notification</code>)的两种类型，它们不同于广播通知（由<code>NSNotificationCenter</code>类管理）和键值观察通知(<code>key - value obverse</code> )。即使<code>app</code>没有在前台运行，用户通知也能让用户知道有关于他们的新消息。该信息可以是简单的一条关于用户的消息，或者是即将发生的日程表事件，或者是远程服务器上新的数据。当操作系统呈现用户通知时，无论是来自本地的还是远程的通知，它们的展现形式都是一样的。他们可以显示警告信息，也可以在应用图标上显示<code>badge</code>，或者同时播放声音。</p>
<p>当收到用户通知时，用户可以点击它来启动相关的应用程序，查看详细信息。他们也可以选择忽略该通知，在这种情况下，该应用不会被激活。</p>
<p>本地和远程通知的根本目的是使应用程序不在前台运行时也能提醒用户有关于他们的新消息。例如–一封新邮件或即将到来的约会。本地通知和远程通知的本质区别很简单︰</p>
<ul>
<li>本地通知由一个应用程序在同一个设备上生成和传递。</li>
<li>远程通知，也被称为推送通知，由你的服务器发送到苹果推送通知服务(<code>Apple Push Notification service</code>)，然后由<code>APNS</code>向设备推送通知。</li>
</ul>
<h1 id="本地和远程通知对用户的表现形式是一样的"><a href="#本地和远程通知对用户的表现形式是一样的" class="headerlink" title="本地和远程通知对用户的表现形式是一样的"></a>本地和远程通知对用户的表现形式是一样的</h1><p>用户可以通过下面的几种方式得到通知：</p>
<ul>
<li>屏幕上的<code>alert</code>或<code>banner</code></li>
<li>应用程序的图标的<code>badge</code></li>
<li>伴随<code>alert</code>，<code>banner</code>，<code>badge</code>的声音</li>
</ul>
<p>从用户的角度看本地和远程的通知表明在应用程序里面有用户感兴趣的东西。</p>
<p>例如，有一个管理待办事项应用程序，在列表中的每个项目都有一个必须完成的项目的日期和时间。用户可以要求应用程序在该日期到来前的一个特定的时间间通知它。要实现此行为，应用程序生成一个关于这个日期和时间的本地通知。该应用选择指定一个<code>badge（1）</code>和播放一个声音，而不是显示一个<code>alert</code>。届时，iOS设备播放的声音，在应用程序的图标的右上角显示一个<code>1</code>。如下图：<br><img src="http://7xvudw.com1.z0.glb.clouddn.com/Screen%20Shot%202016-08-17%20at%2015.08.28.png" alt=""></p>
<p>用户听到的声音和看到<code>badge</code>，并启动应用程序，查看待办事项。用户指定设备上的哪些<code>app</code>可以发送通知，他们也可以对某些<code>app</code>启用或者禁用某些通知类型（即<code>alert</code>,<code>badge</code>,<code>sound</code>）。</p>
<h1 id="本地和远程通知对于app来说是不一样的"><a href="#本地和远程通知对于app来说是不一样的" class="headerlink" title="本地和远程通知对于app来说是不一样的"></a>本地和远程通知对于<code>app</code>来说是不一样的</h1><p>当你的应用程序是在前台运行时，UIKit直接把本地和远程通知传递到应用程序的委托对象，而不显示任何系统UI。对于收到的本地通知， UIKit调用<code>application：didReceiveLocalNotification：</code>方法,而对于远程通知则调用<code>application：didReceiveRemoteNotification：fetchCompletionHandler：</code>方法。使用提供的通知字典来更新你的应用。因为你的应用程序正在运行，你可以悄悄的更新你的用户界面，让用户知道有新的信息。</p>
<p>当你的应用程序必须启动以接收通知，<code>UIKit</code>将包括<code>UIApplicationLaunchOptionsLocalNotificationKey</code>或<code>UIApplicationLaunchOptionsRemoteNotificationKey</code>的键的词典传递给你的应用程序委托的<code>application：willFinishLaunchingWithOptions：</code>和<code>application：didFinishLaunchingWithOptions：</code>方法。这些键的存在可以让你知道有通知数据等待被处理，并给你一个机会，以适当地配置你的应用程序的界面。你不需要在这些方法中处理通知。在你的应用程序运行后，UIKit调用你的应用程序委托的其他方法，如<code>application：didReceiveLocalNotification</code>方法，来让你处理通知数据。哪个方法被调用取决于你的实现和用户与系统<code>UI</code>的交互。</p>
<p>当你的应用程序正在运行，但不是最前端，<code>UIKit</code>显示系统<code>UI</code>，然后传递结果到后台运行的<code>app</code>。和正在运行的<code>app</code>类似，<code>UIKit</code>调用相关的方法来处理通知。如果无法在后台交付通知数据，<code>UIKit</code>的等待你的应用程序下一次运行的时候再传递通知数据。</p>
<h1 id="本地通知"><a href="#本地通知" class="headerlink" title="本地通知"></a>本地通知</h1><p>本地通知非常适合应用与基于时间的行为，如日历和待办事项列表的应用程序。在后台长时间运行的程序而被<code>iOS</code>系统限制的<code>app</code>可能会发现本地通知也有用。例如，依赖于服务器消息或数据的应用程序可以轮询服务器传人的新消息当<code>app</code>在后台运行时;如果有新消息或更新可以下载，它们就可以处理需要的数据，并在适当的时候通知用户。</p>
<p>本地通知是<code>UILocalNotification</code>或<code>NSUserNotification</code>的实列并有三种不用类型的属性：</p>
<ul>
<li><strong>Scheduled time</strong><br>您必须指定操作系统传递通知的日期和时间;这个被称为<code>fire date</code>。可以限定<code>fire date</code> 的时区，这样当用户旅行时系统可以调整触发时间。你也可以要求系统以一个固定的间隔（周，月，等待）来触发通知。</li>
<li><strong>Notification type</strong><br>这些属性包括警报消息，默认的动作按钮的标题，应用程序图标<code>badge</code>数量，要播放的声音，以及1<code>iOS8</code>和更高版本的自定义动作的类别。</li>
<li><strong>Custom data</strong><br>本地通知包含的用户信息字典的自定义数据。</li>
</ul>
<p>设备上的每个应用程序被限制为最多64个本地通知。系统会丢弃超过此限制的通知，只保留最近要触发的64个通知。重复通知被视为一个单个的通知。</p>
<h1 id="远程通知"><a href="#远程通知" class="headerlink" title="远程通知"></a>远程通知</h1><p>iOS或Mac应用程序通常是基于客户端/服务器模式的较大的应用程序的一部分。该应用程序的客户端安装在设备或计算机上;该应用的服务器侧具有向它的客户端应用提供数据的主要功能，并且因此被称为提供者(<code>Provider</code>)。客户端应用程序会定期与服务器连接并下载正在等待它的任何数据。电子邮件和社交网络应用程序是该客户端/服务器模型的例子。</p>
<p>但是，如果应用程序没有连接到提供者，甚至当应用程序正在在设备或计算机上运行时，提供者有新的数据等它下载？它是如何知道这个等待数据？远程通知是解决这一困境的方法。远程通知是一个提供者传递给设备的操作系统的短消息;操作系统可以通知客户端的应用程序，有数据要下载，有新的消息要浏览，等等。如果用户启用该功能（在<code>iOS</code>）并且该应用正确注册，通知被传递到操作系统和应用程式。苹果推送通知服务（<code>APNs</code>）是远程通知功能的主要技术。</p>
<p>远程通知服务和桌面系统上的后台应用程序目的差不多，但没有额外的开销。通知会在当前没有运行，或者在iOS中的情况下，没有运行在前台的应用中发生。操作系统代表应用程序接收远程通知，并提醒用户。然后，如果用户启动应用程序，它会下载服务器提供的数据。如果在应用程序正在运行时通知被传递到<code>app</code>，应用程序可以选择直接处理通知。</p>
<p>正如它的名字所暗示的，苹果推送通知服务使用一个远程的设计以传递远程通知到设备和计算机。推式设计(<code>push design</code>)不同于它的反面拉式的设计(<code>pull design</code>)，该通知的收件人被动侦听更新，而不是积极地轮询。<code>APNs</code>使用持久<code>IP</code>连接来实现远程通知。</p>
<p>大多数远程通知包含一个<code>payload</code>：一个<code>JSON</code>字典包含已经定义好的如何通知用户的<code>APNs</code>属性。<code>payload</code>越小，通知的性能越好。虽然你可以定义自定义属性，但是不要用远程通知机制来传输数据。远程通知是尽最大努力交付，这具有很高的成功率，但不能保证每次都成功。</p>
<p>当一台设备不在线时，<code>APNs</code>保留上次从该设备上的应用程序的提供者收到的通知。如果该设备上线（联网），<code>APNs</code>会把存储的通知推送到设备。运行<code>iOS</code>的设备接收通过<code>Wi-Fi</code>和蜂窝连接的远程通知;一台运行OS X通过<code>Wi-Fi</code>和以太网连接，接收远程通知。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本地通知和远程通知是用户通知(&lt;code&gt;user notification&lt;/code&gt;)的两种类型，它们不同于广播通知（由&lt;code&gt;NSNotificationCenter&lt;/code&gt;类管理）和键值观察通知(&lt;code&gt;key - value obverse&lt;/code&gt; )。即使&lt;code&gt;app&lt;/code&gt;没有在前台运行，用户通知也能让用户知道有关于他们的新消息。该信息可以是简单的一条关于用户的消息，或者是即将发生的日程表事件，或者是远程服务器上新的数据。当操作系统呈现用户通知时，无论是来自本地的还是远程的通知，它们的展现形式都是一样的。他们可以显示警告信息，也可以在应用图标上显示&lt;code&gt;badge&lt;/code&gt;，或者同时播放声音。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS push notification part three</title>
    <link href="http://guopp.me/2016/08/26/iOS-push-notification-part-three/"/>
    <id>http://guopp.me/2016/08/26/iOS-push-notification-part-three/</id>
    <published>2016-08-26T12:03:42.000Z</published>
    <updated>2016-08-27T08:10:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>苹果的远程推送通知服务(<code>APNs</code>)是远程通知的核心。这是一个强健并且高效的系统来为<code>iOS</code>，<code>watchOS</code>，<code>tvOS</code>设备推送消息。每台设备都和<code>APNs</code>建立了一个加密的可信<code>IP</code>链接，通过这个持久的链接来接收<code>APNs</code>发送给设备的消息。如果通过这个链接发送到设备后，相应的应用不在前台运行，系统会展示相应的警告框提示用户。</p>
<p>你需要使用自己的服务器来为用户生成远程通知。这个服务器被称为<code>Provider</code>，它生成远程通知的数据并且决定什么时候推送这个远程通知。对于每个远程通知，<code>Provider</code>生成通知的<code>payload</code>然后使用<code>HTTP/2</code>的持久的加密链接发送到<code>APNs</code>，<code>APNs</code>负责把通知推送到用户设备。</p>
<a id="more"></a>
<p>苹果的远程推送通知服务(<code>APNs</code>)是远程通知的核心。这是一个强健并且高效的系统来为<code>iOS</code>，<code>watchOS</code>，<code>tvOS</code>设备推送消息。每台设备都和<code>APNs</code>建立了一个加密的可信<code>IP</code>链接，通过这个持久的链接来接收<code>APNs</code>发送给设备的消息。如果通过这个链接发送到设备后，相应的应用不在前台运行，系统会展示相应的警告框提示用户。</p>
<p>你需要使用自己的服务器来为用户生成远程通知。这个服务器被称为<code>Provider</code>，它生成远程通知的数据并且决定什么时候推送这个远程通知。对于每个远程通知，<code>Provider</code>生成通知的<code>payload</code>然后使用<code>HTTP/2</code>的持久的加密链接发送到<code>APNs</code>，<code>APNs</code>负责把通知推送到用户设备。</p>
<h1 id="远程通知的路径"><a href="#远程通知的路径" class="headerlink" title="远程通知的路径"></a>远程通知的路径</h1><p><code>APNs</code>负责分发你的<code>Provider</code>传过来的通知到你的应用的用户的设备。当你的<code>Provider</code>需要推送一个通知，它把这个通知和设备的<code>token</code>一起发送到<code>APNs</code>。<code>APNs</code>会把这个通知传递到用户设备，设备上的操作系统会负责传递这个通知到相应的应用程序。如下图：<br><img src="http://7xvudw.com1.z0.glb.clouddn.com/Screen%20Shot%202016-08-26%20at%2016.53.28.png" alt=""></p>
<p>你传给服务器的设备<code>token</code>和手机号是类似的。它包含设备的信息，<code>APNs</code>使用这个<code>token</code>能定位你的应用程序安装的设备。<code>APNs</code>也会用它来验证通知发送的过程中的路由信息。通过注册远程通知服务，系统会发送设备的<code>token</code>给你的应用程序。</p>
<p>通知的<code>payload</code>是你想发送给设备的数据，它是一个<code>JSON</code>字典。<code>payload</code>包含系统提示用户的方式，如警告框，<code>badge</code>,声音。它也能包括你自定义的数据。</p>
<p>下图展示了<code>APNs</code>在设备和<code>Provider</code>之间的虚拟网络。在<code>APNs</code>的两边－－设备方和<code>APNs</code>和<code>Provider</code>方和<code>APNs</code>之间－－都会有多个连接。在<code>Provider</code>和<code>APNs</code>的这边，它们被称为网关。通常都会有多个<code>Provider</code>,每个<code>Provier</code>都通过网关和<code>APNs</code>建立一个或多个持久的加密连接。这些<code>Provider</code>通过<code>APNs</code>发送通知到它们的客户端设备上。<br><img src="http://7xvudw.com1.z0.glb.clouddn.com/Screen%20Shot%202016-08-26%20at%2017.47.07.png" alt=""></p>
<h1 id="推送服务质量"><a href="#推送服务质量" class="headerlink" title="推送服务质量"></a>推送服务质量</h1><p><code>APNs</code>默认包含一个存储和转发功能的组件。如果要推送的设备不在线，要推送的通知会被<code>APNs</code>暂存一段时间，当设备上线之后会推送到设备。但是只有一个通知会被暂存。当有多个通知推送到设备而设备此时不在线时，最新的一个通知会被暂存，而以前的通知会被丢弃。这被称为通知合并。</p>
<p>如果设备长时间离线，那么所有的通知都会被丢弃。</p>
<h2 id="安全架构"><a href="#安全架构" class="headerlink" title="安全架构"></a>安全架构</h2><p>为了保证安全的通信，<code>APNs</code>使用两种不同的信任级别在<code>Porvider</code>和设备之间：<code>connection trust</code>和<code>token trust</code>。</p>
<p><code>Connection trust</code>保障<code>APNs</code>是连接到一个被授权可以推送通知的<code>Provider</code>上。<code>APNs</code>也会使用<code>connection trust</code>来连接到设备以保证设备的合法性。<code>APNs</code>到设备的可信连接是<code>APNs</code>自动处理的，但是<code>Provider</code>到<code>APNs</code>之间的可信连接必须要你自己负责。</p>
<p><code>Token trust</code>确保通知是在合法的起始点和终止点之间传送。<code>Token trust</code>涉及到设备<code>token</code>的使用，这是分配给特定设备上的特定应用的标识符。每个应用通过注册远程通知服务来获取它的唯一设备标识符，而且必须要把这个标识符传到服务器。因此，这个标识符应该和通知一同被<code>Provider</code>发送到<code>APNs</code>。提供这个标识符用于传递通知到特定的设备上的特定应用程序。</p>
<blockquote>
<p>注意：设备标识符并不能用来区分设备的唯一性。</p>
</blockquote>
<p><code>APNs</code>也会使用必要的证书，CA证书和密钥（公钥和私钥）来验证<code>Provider</code>和设备之间的连接。</p>
<h2 id="Provider到APNs之间的可信连接"><a href="#Provider到APNs之间的可信连接" class="headerlink" title="Provider到APNs之间的可信连接"></a><code>Provider</code>到<code>APNs</code>之间的可信连接</h2><p>每个<code>Provider</code>都必须要有一个唯一的证书和私钥，<code>APNs</code>会使用它们来验证它和<code>Provider</code>之间的连接。<code>Provider</code>的证书标示它所支持的应用的<code>bundle id</code>。</p>
<p>你的<code>Provider</code>通过<code>TLS</code>的对等网络建立可信连接到<code>APNs</code>。当<code>TLS</code>连接初始化后，你会得到<code>APNs</code>的服务端证书，然后在你这边验证证书。然后你发送你的<code>Provider</code>证书给<code>APNs</code>，<code>APNs</code>也会在它那边验证你的证书。当这个过程完成后，一个安全和可信的<code>TLS</code>就被合法的<code>Provider</code>建立了。<br><img src="http://7xvudw.com1.z0.glb.clouddn.com/Screen%20Shot%202016-08-26%20at%2019.52.08.png" alt=""></p>
<h2 id="APNs到设备的可信连接"><a href="#APNs到设备的可信连接" class="headerlink" title="APNs到设备的可信连接"></a><code>APNs</code>到设备的可信连接</h2><p>每个设备都有一个设备证书和私钥。它们用来验证和<code>APNs</code>之间的连接。设备在激活的时候会获取这个证书和私钥然后把它们保存在钥匙串中。</p>
<p>你不需要做任何事来建立<code>APNs</code>和设备之间的可信连接。<code>APNs</code>会通过<code>TLS</code>来建立到设备的可信连接。在这种情况下，设备初始化<code>TLS</code>连接，<code>APNs</code>返回服务器证书.设备验证这个证书然后发送自己的设备证书给<code>APNs</code>,<code>APNs</code>验证这个证书。<br><img src="http://7xvudw.com1.z0.glb.clouddn.com/Screen%20Shot%202016-08-26%20at%2020.01.19.png" alt=""></p>
<h2 id="Token的生成和发送"><a href="#Token的生成和发送" class="headerlink" title="Token的生成和发送"></a><code>Token</code>的生成和发送</h2><p>设备想要收到远程通知必须先在系统中注册远程通知服务。当系统收到应用的注册请求时会把这个请求转发到<code>APNs</code>。<code>APNs</code>会使用设备的证书中的信息为应用生成一个唯一的设备<code>token</code>，然后加密这个<code>token</code>再把它返回给设备。系统通过<code>NSData</code>把设备<code>token</code>传递给应用。当收到这个设备<code>token</code>后，应用应该使用二进制或者十六进制把这个<code>token</code>发送给你的服务器。服务器不能把通知推送到没用这个<code>token</code>的设备。流程如下图：<br><img src="http://7xvudw.com1.z0.glb.clouddn.com/Screen%20Shot%202016-08-27%20at%2016.00.07.png" alt=""></p>
<blockquote>
<p><code>APNs</code>的设备<code>token</code>长度是可变的。不要写死长度。</p>
</blockquote>
<p>下图显示设备<code>token</code>的生成和转发路径，还有上传到<code>Provider</code>的部分。<br><img src="http://7xvudw.com1.z0.glb.clouddn.com/Screen%20Shot%202016-08-27%20at%2016.04.15.png" alt=""></p>
<h2 id="Token-Trust-Notification"><a href="#Token-Trust-Notification" class="headerlink" title="Token Trust (Notification)"></a>Token Trust (Notification)</h2><p>每个从<code>Provider</code>发送给<code>APNs</code>的远程通知都必须和<code>device token</code>一起发送。<code>APNs</code>使用它的<code>token key</code>解密通知中的<code>token</code>来确保<code>Provider</code>的合法性。然后使用<code>device token</code>中的<code>device ID</code>来决定推送的目标设备，最后把这个通知推送给目标设备。<br><img src="http://7xvudw.com1.z0.glb.clouddn.com/Screen%20Shot%202016-08-27%20at%2016.08.56.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;苹果的远程推送通知服务(&lt;code&gt;APNs&lt;/code&gt;)是远程通知的核心。这是一个强健并且高效的系统来为&lt;code&gt;iOS&lt;/code&gt;，&lt;code&gt;watchOS&lt;/code&gt;，&lt;code&gt;tvOS&lt;/code&gt;设备推送消息。每台设备都和&lt;code&gt;APNs&lt;/code&gt;建立了一个加密的可信&lt;code&gt;IP&lt;/code&gt;链接，通过这个持久的链接来接收&lt;code&gt;APNs&lt;/code&gt;发送给设备的消息。如果通过这个链接发送到设备后，相应的应用不在前台运行，系统会展示相应的警告框提示用户。&lt;/p&gt;
&lt;p&gt;你需要使用自己的服务器来为用户生成远程通知。这个服务器被称为&lt;code&gt;Provider&lt;/code&gt;，它生成远程通知的数据并且决定什么时候推送这个远程通知。对于每个远程通知，&lt;code&gt;Provider&lt;/code&gt;生成通知的&lt;code&gt;payload&lt;/code&gt;然后使用&lt;code&gt;HTTP/2&lt;/code&gt;的持久的加密链接发送到&lt;code&gt;APNs&lt;/code&gt;，&lt;code&gt;APNs&lt;/code&gt;负责把通知推送到用户设备。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
