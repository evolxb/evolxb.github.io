<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>guopp</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://guopp.me/"/>
  <updated>2016-08-27T06:50:05.000Z</updated>
  <id>http://guopp.me/</id>
  
  <author>
    <name>guopp</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS push notification part two</title>
    <link href="http://guopp.me/2016/08/27/iOS-push-notification-part-two/"/>
    <id>http://guopp.me/2016/08/27/iOS-push-notification-part-two/</id>
    <published>2016-08-27T06:44:00.000Z</published>
    <updated>2016-08-27T06:50:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>应用程序必须进行适当配置，才可以接受本地或远程通知。配置过程在<code>iOS</code>和<code>OS X</code>略有不同，但基本原理是相同的。在启动时，您的应用程序注册接收通知，并与系统配合来配置通知支持。一旦注册完成，可以开始传递给你的应用程序创建的通知。然后，您的应用程序处理这些收到的通知，并提供相应的响应。</p>
<p>在<code>IOS</code>和<code>tvOS</code>，注册通知被分成两个部分：注册所支持的用户交互和注册通知自己。注册您的应用程序支持的用户交互类型来告诉操作系统要如何通知用户当一个通知到达时。本地或远程通知都需要此步骤。对于远程通知，必须执行注册的第二步来获得<code>APNs</code>用于传送通知的应用程序特定的设备<code>token</code>。 （对于本地通知，没有第二个注册步骤。）在<code>OS X</code>中，仅支持远程通知应用程序才需要注册。</p>
<a id="more"></a>
<p>应用程序必须进行适当配置，才可以接受本地或远程通知。配置过程在<code>iOS</code>和<code>OS X</code>略有不同，但基本原理是相同的。在启动时，您的应用程序注册接收通知，并与系统配合来配置通知支持。一旦注册完成，可以开始传递给你的应用程序创建的通知。然后，您的应用程序处理这些收到的通知，并提供相应的响应。</p>
<p>在<code>IOS</code>和<code>tvOS</code>，注册通知被分成两个部分：注册所支持的用户交互和注册通知自己。注册您的应用程序支持的用户交互类型来告诉操作系统要如何通知用户当一个通知到达时。本地或远程通知都需要此步骤。对于远程通知，必须执行注册的第二步来获得<code>APNs</code>用于传送通知的应用程序特定的设备<code>token</code>。 （对于本地通知，没有第二个注册步骤。）在<code>OS X</code>中，仅支持远程通知应用程序才需要注册。</p>
<h1 id="注册通知支持的用户交互类型"><a href="#注册通知支持的用户交互类型" class="headerlink" title="注册通知支持的用户交互类型"></a>注册通知支持的用户交互类型</h1><p>在<code>iOS8</code>和更高版本的系统中，使用本地或远程通知的应用必须注册该应用程序支持的用户交互类型。应用程序可以要求图标<code>badge</code>，显示警告信息，或播放声音。当您请求这些互动类型的时候，应该先查看该用户已允许什么类型的交互。如果用户不允许某个特定类型的交互，系统将忽略尝试以这种方式与用户进行交互。例如，如果一个通知要显示警告信息，并播放声音，而用户不允许声音，系统会显示警告信息，但不播放声音。</p>
<p>要注册您的应用程序支持的交互类型，调用<code>registerUserNotificationSettings：</code>方法。使用<code>setting object</code>来指定应用程序是否<code>badge</code>图标，是否显示警告信息，或播放声音。如果你不要求任何交互类型，系统悄悄的推送所有通知到你的应用程序。下面的代码显示了支持显示警报消息，并播放声音的应用程序的代码段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">UIUserNotificationType types = (UIUserNotificationType) (UIUserNotificationTypeBadge |</div><div class="line">UIUserNotificationTypeSound | UIUserNotificationTypeAlert);</div><div class="line">UIUserNotificationSettings *mySettings = [UIUserNotificationSettings settingsForTypes:types categories:nil];</div><div class="line">[[UIApplication sharedApplication] registerUserNotificationSettings:mySettings];</div></pre></td></tr></table></figure></p>
<p>除了注册您的应用程序的交互类型，应用程序可以注册一个或多个类别。类别都支持本地和远程通知，并使用它们来标识通知的目的。你的<code>iOS</code>应用程序可以使用类别标识符来决定如何处理通知。在<code>watchOS</code>，类别也被用来定制显示给用户的通知接口。</p>
<p>从<code>iOS8</code>开始，你可以选择通过注册自定义动作的通知类型创建可以执行动作的通知。当一个可执行的通知到达时，系统会为每个注册的操作添加按钮，并添加这些按钮到通知界面。这些操作按钮是用户能够执行相关通知任务的快捷方式。例如，对于会议的远程通知邀请可能会提供动作来接受或拒绝该会议。当用户点击你的一个动作按钮，系统会通知你的应用程序，让你有机会可以执行相应的动作。</p>
<p>当应用程序第一次调用<code>registerUserNotificationSettings：</code>方法，<code>iOS</code>设备将提示用户允许指定的交互。在后续应用启动中，调用此方法不会提示用户。调用方法后，<code>iOS</code>异步的报告结果到<code>application：didRegisterUserNotificationSettings：</code>方法中。当你第一次注册你的设置，iOS在调用此方法之前等待用户的反应，但在随后的调用将返回现有的用户设置。</p>
<p>用户可以通过<code>Setting app</code>在任何时候改变你的应用程序通知设置。由于设置可以改变，始终调用<code>registerUserNotificationSettings：</code>在应用启动时，然后使用<code>application：didRegisterUserNotificationSettings：</code>方法来获得结果。如果用户不允许特定的通知类型，避免使用这些类型来配置你的应用程序的本地和远程通知。</p>
<h1 id="注册远程通知"><a href="#注册远程通知" class="headerlink" title="注册远程通知"></a>注册远程通知</h1><p>想要接收远程通知必须注册苹果推送通知服务（<code>APNs</code>）来获得一个<code>device token</code>。在<code>iOS8</code>和更高版本，注册包括以下步骤：</p>
<ol>
<li>在注册应用程序的支持的用户交互类型。</li>
<li>调用<code>registerForRemoteNotifications</code>方法来注册远程通知。 （在<code>OS X</code>中，使用<code>registerForRemoteNotificationTypes：</code>方法来注册你的应用程序支持交互类型并在同一步中注册远程通知。）</li>
<li>使用应用程序委托<code>application：didRegisterForRemoteNotificationsWithDeviceToken：</code>方法来接收提供远程通知所需要的<code>device token</code>。使用<code>application：didFailToRegisterForRemoteNotificationsWithError：</code>方法来处理错误。</li>
<li>如果注册成功，发送<code>device token</code>到用于生成远程通知的服务器</li>
</ol>
<blockquote>
<p><code>iOS</code>注意：如果蜂窝或Wi-Fi连接不可用，无论是<code>application：didRegisterForRemoteNotificationsWithDeviceToken：</code>方法或者<code>application：didFailToRegisterForRemoteNotificationsWithError：</code>方法都不会被调用。对于<code>Wi-Fi</code>连接，这有时会发生在设备不能超过配置端口连接到<code>APNs</code>。如果发生这种情况，用户可以通过连接到另一个不屏蔽所需端口的<code>Wi-Fi</code>网络，或者等<code>iPhone</code>或<code>iPad</code>的蜂窝数据服务变得可用。在这两种情况下，该设备应能够建立连接，然后委托方法被调用。</p>
</blockquote>
<p><code>device token</code>是将通知推送到到特定设备上的应用程序的关键。<code>Device token</code>可以改变，所以应用需要在每次启动时重新注册，并把接收到的<code>token</code>回传到你的服务器。如果无法更新设备<code>token</code>，远程通知可能不会被传递到设备。当用户将备份数据恢复到新设备或电脑，或重新安装操作系统时设备<code>token</code>总是会改变。当将数据迁移到新的设备或计算机，用户必须启动应用程序一次，从而远程通知可以传送到该设备。</p>
<p>永远不要缓存设备<code>token</code>;总是从系统中获得<code>token</code>。如果您的应用程序之前注册过远程通知，再调用<code>registerForRemoteNotifications</code>方法不会产生任何额外的开销，<code>iOS</code>会立即返回现有的设备<code>token</code>到应用程序委托。此外，iOS会随时调用你的委托方法当设备<code>token</code>变化的时候，而不是仅仅只在你的应用程序注册或重新注册远程通知的时候。</p>
<p>下面的代卖显示了如何在<code>iOS</code>应用中注册远程通知。应用程序注册支持的动作类型后，下面的方法调用<code>registerForRemoteNotifications</code>方法。在接收到设备<code>token</code>后，委托方法调用自定义代码来发送<code>token</code>到服务器。在<code>OS X</code>中，注册交互类型的方法是不同的，但是用于处理注册的委托方法是类似的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">- (void)applicationDidFinishLaunching:(UIApplication *)app &#123;</div><div class="line">    </div><div class="line">    UIUserNotificationType types = UIUserNotificationTypeBadge |  </div><div class="line">    UIUserNotificationTypeSound | UIUserNotificationTypeAlert; </div><div class="line">    UIUserNotificationSettings *mySettings = [UIUserNotificationSettings</div><div class="line">    settingsForTypes:types categories:nil]; [[UIApplication sharedApplication]</div><div class="line">    registerUserNotificationSettings:mySettings];</div><div class="line">    </div><div class="line">    // Register for remote notifications. </div><div class="line">    [[UIApplication sharedApplication] registerForRemoteNotifications];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Handle remote notification registration. </div><div class="line">- (void)application:(UIApplication *)app didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)devToken &#123; </div><div class="line"></div><div class="line">    const void *devTokenBytes = [devToken bytes];</div><div class="line">    self.registered = YES; [self sendProviderDeviceToken:devTokenBytes]; // custom method</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)application:(UIApplication *)app didFailToRegisterForRemoteNotificationsWithError:(NSError *)err &#123; </div><div class="line"></div><div class="line">    NSLog(@&quot;Error in registration. Error: %@&quot;, err); </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在<code>application︰ didFailToRegisterForRemoteNotificationsWithError︰</code>方法中，你应该适当地处理错误对象和禁用与远程通知相关的任何功能。因为通知无论如何都不会被送达，这简直不能更棒，因为不需要处理和显示这些通知。</p>
<h1 id="注册可以执行动作的通知类型"><a href="#注册可以执行动作的通知类型" class="headerlink" title="注册可以执行动作的通知类型"></a>注册可以执行动作的通知类型</h1><p>可以执行动作的通知可以让你在标准的本地和远程通知界面上添加自定义的动作按钮。可动作的通知给用户一种快速且简单的方式执行和通知相关的任务来响应通知。在<code>iOS8</code>之前，通知只有一种默认的动作。在<code>iOS8</code>之后，在锁屏界面，在通知中心的通知横幅和通知条目上都可以有一个或两个自定义的动作按钮。<code>modal alert</code> 甚至能显示四个按钮。当用户点击了其中的自定义按钮，<code>iOS</code>会通知你的应用来让你执行该按钮相关的任务。</p>
<blockquote>
<p>注意：<code>OS X</code> 并没有这种可以执行动作的通知。</p>
</blockquote>
<h2 id="定义你的可执行动作的通知"><a href="#定义你的可执行动作的通知" class="headerlink" title="定义你的可执行动作的通知"></a>定义你的可执行动作的通知</h2><p>自定义动作的配置取决于定义一个或多个类别的通知。每个类别代表应用会收到的一种类型的通知，你必须定义你的应用所支持的类别。对于每个类别中，可以定义收到该类型的通知时，用户可能采取的动作。然后，使用iOS的<code>registerUserNotificationSettings</code>注册类别，动作和应用支持的交互类型。</p>
<p>每个自定义动作包括按钮标题和iOS要显示给用户的信息当用户选择该按钮时。通过创建UIMutableUserNotificationAction类的实例并适当配置其属性来产生一个动作。下面的代码创建一个单一的“accept”动作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">UIMutableUserNotificationAction *acceptAction = [[UIMutableUserNotificationAction alloc] init];</div><div class="line">// The identifier that you use internally to handle the action. acceptAction.identifier = @&quot;ACCEPT_IDENTIFIER&quot;;</div><div class="line"></div><div class="line">// The localized title of the action button. </div><div class="line">acceptAction.title = @&quot;Accept&quot;;</div><div class="line"></div><div class="line">// Specifies whether the app must be in the foreground to perform the action. acceptAction.activationMode = UIUserNotificationActivationModeBackground;</div><div class="line"></div><div class="line">// Destructive actions are highlighted appropriately to indicate their nature. acceptAction.destructive = NO;</div><div class="line"></div><div class="line">// Indicates whether user authentication is required to perform the action. acceptAction.authenticationRequired = NO;</div></pre></td></tr></table></figure></p>
<p>创建任何自定义操作对象后，分配这些对象到<code>UIUserNotificationCategory</code>用于定义你的应用的通知类别。如果在启动时配置通知类别，通常创建<code>UIMutableUserNotificationCategory</code>类的一个实例。分配类别标识符到新的实例并使用<code>setActions：forContext：</code>方法来与该类别的自定义动作联系起来。上下文参数，可以让你对不同的系统界面制定不同的动作。默认的上下文情况支持在<code>modal alert</code>时显示四个动作。最小的<code>context</code>只支持两个动作，在锁屏界面，通知横幅，和通知中心中。</p>
<p>下面的例子显示了一个邀请的类别，其中包括来自上面代码中的<code>accept</code>按钮和两个额外的动作。在这个例子中，最小的上下文仅显示接受和拒绝按钮。如果没有指定最小上下文的动作，那么最前面的两个按钮就会被显示。按钮的顺序决定了它们在屏幕上显示的顺序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// First create the category </div><div class="line">UIMutableUserNotificationCategory *inviteCategory = [[UIMutableUserNotificationCategory alloc] init];</div><div class="line"></div><div class="line">// Identifier to include in your push payload and local notification</div><div class="line">inviteCategory.identifier = @&quot;INVITE_CATEGORY&quot;;</div><div class="line"></div><div class="line">// Set the actions to display in the default context </div><div class="line">[inviteCategory setActions:@[acceptAction, maybeAction, declineAction] forContext:UIUserNotificationActionContextDefault];</div><div class="line"></div><div class="line">// Set the actions to display in a minimal context</div><div class="line">[inviteCategory setActions:@[acceptAction, declineAction] forContext:UIUserNotificationActionContextMinimal];</div></pre></td></tr></table></figure></p>
<p>创建完通知动作类别后必须注册这些类别。应用可以注册任意数量的类别，但是每个列别必须是唯一的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSSet *categories = [NSSet setWithObjects:inviteCategory, alarmCategory, ...</div><div class="line"></div><div class="line">UIUserNotificationSettings *settings = [UIUserNotificationSettings settingsForTypes:types categories:categories];</div><div class="line">[[UIApplication sharedApplication] registerUserNotificationSettings:settings];</div></pre></td></tr></table></figure></p>
<p>通知的类型和动作的类别都是使用<code>UIUserNotificationSettings</code>的类方法<code>settingsForTypes:categories:</code>来注册，只是一个的<code>categories</code>参数为<code>nil</code>。</p>
<h2 id="触发可动作的通知"><a href="#触发可动作的通知" class="headerlink" title="触发可动作的通知"></a>触发可动作的通知</h2><p>为了显示你定义好的可动作的通知，你必须推送一个远程通知或者触发一个本地通知。在远程通知的情况下你必须在payload中包括类别的标识符（Code2-1）。对类别的支持是你的应用程序和推送服务器之间的合作完成的。当你的服务器想推送一个通知给用户，它可以在payload中添加合适的类别值。如果iOS得到一个有类别值的推送通知，它会在应用中搜索注册过的有一样值的类别，如果找到匹配的就会显示响应的动作按钮。</p>
<p>推送的payload的大小被HTTP/2提供的API限制，在2015年12月是4KB。(在2014年，Apple在遗留的二进制接口中把payload的大小限制从256字节提高到2KB)<br>Code2-1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;aps&quot;: &#123;</div><div class="line">        &quot;alert&quot;: &quot;You&apos;re invited!&quot;,</div><div class="line">        &quot;category&quot;: &quot;INVITE_CATEGORY&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在本地通知的情况下，你像平常一样创建通知，设置动作类别，然后触发通知。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">UILocalNotification *notification = [[UILocalNotification alloc] init]; </div><div class="line">. . . </div><div class="line">notification.category = @&quot;INVITE_CATEGORY&quot;; </div><div class="line">[[UIApplication sharedApplication] scheduleLocalNotification:notification];</div></pre></td></tr></table></figure></p>
<h2 id="处理可动作通知"><a href="#处理可动作通知" class="headerlink" title="处理可动作通知"></a>处理可动作通知</h2><p>如果你的应用不是在前台运行，当用户滑动或者点击通知时，<code>iOS</code>会在前台启动你的应用然后调用<code>application:didFinishLaunchingWithOptions:</code>并在<code>options</code>字典中包括本地或远程通知。在远程通知的情况下，系统还会调用<code>application:didReceiveRemoteNotification:fetchCompletionHandler:</code>。</p>
<p>如果你的应用已经在前台，<code>iOS</code>就不会显示这个通知。相反，<code>iOS</code>会调用<code>application:didReceiveLocalNotification:</code>或者<code>application:didReceiveRemoteNotification:fetchCompletionHandler:</code>。（如果你没有实现<code>application:didReceiveRemoteNotification:fetchCompletionHandler:</code>,iOS会调用<code>application:didReceiveRemoteNotification:</code>）</p>
<p>最后，为了能在<code>iOS8</code>或之后的系统里处理自定义动作，你必须实现下面两个方法中的至少一个：<code>application:handleActionWithIdentifier:forRemoteNotification:completionHandler:</code>,<code>application:handleActionWithIdentifier:forLocalNotification:completionHandler:</code>。这两张情况下你都能得到动作标识符，可以用它来确定用户点击的哪个动作。你也会得到本地或远程通知，你可以用它来获得任何关于这个动作的信息。最后系统会传递给你一个<code>completion handler</code>,当你处理完这个动作之后你必须调用这个<code>handler</code>。下面代码显示了一个自定义动作处理的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (void)application:(UIApplication *) application </div><div class="line">    handleActionWithIdentifier: (NSString *) identifier </div><div class="line">    // either forLocalNotification: (NSDictionary *) notification or</div><div class="line">    forRemoteNotification: (NSDictionary *) notification </div><div class="line">    completionHandler: (void (^)()) completionHandler &#123;</div><div class="line">    </div><div class="line">     if ([identifier isEqualToString: @&quot;ACCEPT_IDENTIFIER&quot;]) &#123;</div><div class="line">        </div><div class="line">        [self handleAcceptActionWithNotification:notification]; </div><div class="line">    &#125;</div><div class="line">        </div><div class="line">    // Must be called when finished </div><div class="line">    completionHandler();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="触发本地通知"><a href="#触发本地通知" class="headerlink" title="触发本地通知"></a>触发本地通知</h1><p>在<code>iOS</code>中,你创建一个<code>UILocalNotification</code>的实例然后使用<code>UIApplication</code>的<code>scheduleLocalNotification:</code>方法来设置通知的触发。在<code>OS X</code>中，你创建一个<code>NSUserNotification</code>的实例，然后<code>NSUserNotificationCenter</code>负责设置传递它。（<code>OS X</code>应用也可以实现<code>NSUserNotificationCenterDelegate</code>协议来自定义<code>NSUserNotificationCenter</code>的行为。）</p>
<p>在iOS中创建和触发本地通知需要你执行以下步骤：</p>
<ol>
<li>在iOS8或更高的系统版本中，需要注册通知类型。（在OS X和早期的iOS版本中，你只需要为远程通知注册通知类型）。如果你已经注册了通知类型，则可以使用<code>currentUserNotificationSettings</code>来获取用户在应用中接受的通知类型。</li>
<li>创建一个<code>UILocalNotification</code>实例。</li>
<li>设置一个系统触发通知的日期和时间。这就是<code>fireDate</code>属性。<br>如果你设置<code>timeZone</code>属性为当前语言环境的<code>NSTimeZone</code>实例，那么系统会自定调整触发时间当设备进入到不同的时区。<br>你也可以设置固定时间间隔来触发本地通知（每日，每周，每月，等等）</li>
<li>适当的配置<code>alert</code>,<code>icon badge</code>,<code>sound</code>。这样系统触发通知时就会使用这些配置来展示通知的界面。<ul>
<li><code>alert</code>有<code>message</code>，动作按钮的<code>title</code>，和<code>slider</code>(<code>alertAction</code>)属性。给它们指定一个本地化的字符串值。如果通知可以在<code>Apple Watch</code>上显示，也给<code>alertTitle</code>属性设置一个值。</li>
<li>使用<code>applicationIconBadgeNumber</code>属性来给应用的图标上设置一个<code>badge number</code>.</li>
<li>给<code>soundName</code>属性设置值来播放声音。你可以直接设置应用程序的资源包中的一个非本地化的文件名来设置属性值，也可以使用<code>UILocalNotificationDefaultSoundName</code>来获得默认的系统声音。播放声音应该和其他两种中至少一种同时作用，而不应该仅仅只是单独播放声音。</li>
</ul>
</li>
<li>另外你也可以使用<code>userInfo</code>属性为通知添加自定义的数据。例如：当一个<code>CloudKit</code>记录更改后所触发的通知中就包括这条纪录的标识符，因此<code>handler</code>就能够得到这条纪录并更新它。</li>
<li>另外在iOS8之后的系统中，本地通知也可以使用自定义可动作的通知，因此你的应用可以执行相应的动作来响应用户交互。</li>
<li>安排本地通知的交付给系统。<br>使用<code>scheduleLocalNotification:</code>来交付通知给系统。系统使用<code>UILocalNotification</code>实例中的<code>fire date</code>来触发通知。或者你也可以使用<code>presentLocalNotificationNow:</code>来立即触发这个通知。</li>
</ol>
<p>下面的代码模拟一个<code>to-do list</code>的应用在待办事件即将到来前通知用户。有几个地方需要注意，<code>alertBody</code>,<code>alertAction</code>,<code>alertTitle</code>属性都是主<code>bundle</code>中的本地化字符串。它也在<code>userInfo</code>属性中添加了待办事项的名字。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">- (void)scheduleNotificationWithItem:(ToDoItem *)item interval:(int)minutesBefore &#123;</div><div class="line"></div><div class="line">    NSCalendar *calendar = [NSCalendar autoupdatingCurrentCalendar]; </div><div class="line">    NSDateComponents *dateComps = [[NSDateComponents alloc] init]; </div><div class="line">    [dateComps setDay:item.day]; </div><div class="line">    [dateComps setMonth:item.month]; </div><div class="line">    [dateComps setYear:item.year]; </div><div class="line">    [dateComps setHour:item.hour]; </div><div class="line">    [dateComps setMinute:item.minute]; </div><div class="line">    NSDate *itemDate = [calendar dateFromComponents:dateComps];</div><div class="line"></div><div class="line">    UILocalNotification *localNotif = [[UILocalNotification alloc] init]; </div><div class="line">    if (localNotif == nil)</div><div class="line">        return; </div><div class="line">     localNotif.fireDate = [itemDate dateByAddingTimeIntervalInterval:- (minutesBefore*60)]; </div><div class="line">     localNotif.timeZone = [NSTimeZone defaultTimeZone];</div><div class="line"></div><div class="line">    localNotif.alertBody = [NSString stringWithFormat:NSLocalizedString(@&quot;%@ in %i minutes.&quot;, nil), item.eventName, minutesBefore]; </div><div class="line">    localNotif.alertAction = NSLocalizedString(@&quot;View Details&quot;, nil);</div><div class="line"></div><div class="line">    localNotif.alertTitle = NSLocalizedString(@&quot;Item Due&quot;, nil);</div><div class="line"></div><div class="line">    localNotif.soundName = UILocalNotificationDefaultSoundName;</div><div class="line"></div><div class="line">    localNotif.applicationIconBadgeNumber = 1;</div><div class="line"></div><div class="line">    NSDictionary *infoDict = [NSDictionary dictionaryWithObject:item.eventName forKey:ToDoItemKey]; </div><div class="line">    localNotif.userInfo = infoDict;</div><div class="line"></div><div class="line">    [[UIApplication sharedApplication] scheduleLocalNotification:localNotif];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>你可以通过调用<code>cancelLocalNotification</code>来取消特定的通知，也可以使用<code>cancelAllLocalNotifications</code>来取消所以的本地通知。这两张手动取消通知的方法都会关闭正在显示的通知。</p>
<p>应用也会发现本地通知非常有用当它们在后台运行的时候，当有用户感兴趣的新消息，数据和其他的一些东西出现时。这种情况下，应用可以使用<code>presentLocalNotificationNow:</code>来立即触发一个本地通知。（<code>iOS</code>允许应用在后台允许一小段时间）</p>
<h1 id="处理本地和远程通知"><a href="#处理本地和远程通知" class="headerlink" title="处理本地和远程通知"></a>处理本地和远程通知</h1><p><strong>当通知被交付时而应用不再前台运行时</strong>。这种情况下，系统显示这个通知，显示一个<code>alert</code>，<code>badge app icon</code>，或者播放一个声音，显示一个或多个动作按钮让用户点击。</p>
<p><strong>用户点击iOS8系统通知中一个动作按钮</strong>。这种情况下，iOS调用<code>application:handleActionWithIdentifier:forRemoteNotification:completionHandler:</code>或者<code>application:handleActionWithIdentifier:forLocalNotification:completionHandler:</code>。在上面两种情况下，你都能得到按钮的标识符以此来判断用户点击的哪个按钮。你也可以得到本地或者远程的通知，来获取你需要的数据。</p>
<p><strong>用户点击了默认的动作按钮或者点击了应用的图片</strong>。如果默认的动作按钮被用户点击，系统会启动应用程序然后调用<code>application:didFinishLaunchingWithOptions:</code>传入通知的<code>payload</code>或者本地通知对象。虽然<code>application:didFinishLaunchingWithOptions:</code>这个方法里不是处理通知的最佳时机，但是在这里获取通知的<code>payload</code>可以让你有机会在<code>handler</code>方法调用之前开始处理和通知相关的操作。</p>
<p>对于远程通知，系统也会调用<code>application:didReceiveRemoteNotification:fetchCompletionHandler:</code></p>
<p>如果在OS X上用户点击了应用图标，应用会调用<code>applicationDidFinishLaunching:</code>方法，然后应用代理可以获得远程通知。如果在iOS上点击应用图标，应用也会调用相同的方法，但是并不能获取通知内容。</p>
<p><strong>当通知被交付时应用程序在前台运行</strong>。应用会调用<code>application:didReceiveRemoteNotification:fetchCompletionHandler:</code>或者<code>application:didReceiveLocalNotification:</code>。（如果<code>application:didReceiveRemoteNotification:fetchCompletionHandler:</code>方法没有实现，系统会调用<code>application:didReceiveRemoteNotification:</code>这个方法）.在OS X中，系统会调用<code>application:didReceiveRemoteNotification:</code>方法。</p>
<p>应用程序可以使用传入的远程通知的<code>payload</code>或者在iOS中使用<code>UILocalNotification</code>的实例来帮助设置上下文处理通知相关的操作。在理想的情况下，应用代理在不同的平台执行下面的操作来传递远程和本地通知：</p>
<ul>
<li>对于OS X，应用代理会遵循<code>NSApplicationDelegate</code>协议，实现<code>application:didReceiveRemoteNotification:</code>方法</li>
<li>对于iOS，应用代理会遵循<code>UIApplicationDelegate</code>代理，实现<code>application:didReceiveRemoteNotification:fetchCompletionHandler:</code>或者<code>application:didReceiveLocalNotification:</code>方法。为了响应通知动作，实现<code>application:handleActionWithIdentifier:forLocalNotification:completionHandler:</code>或者<code>application:handleActionWithIdentifier:forRemoteNotification:completionHandler:</code></li>
</ul>
<p>下面的代码实现了<code>application:didFinishLaunchingWithOptions:</code>方法来处理本地通知。它从<code>options</code>字典中使用<code>UIApplicationLaunchOptionsLocalNotificationKey</code>键得到了一个<code>UILocalNotification</code>的实例。从<code>UILocalNotification</code>实例的<code>userInfo</code>字典中访问到<code>to-do</code>事项并设置应用的初始上下文。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (BOOL)application:(UIApplication *)app didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; </div><div class="line">    UILocalNotification *localNotif = [launchOptions objectForKey:UIApplicationLaunchOptionsLocalNotificationKey];</div><div class="line"></div><div class="line">    if (localNotif) &#123; </div><div class="line">    NSString *itemName = [localNotif.userInfo objectForKey:ToDoItemKey];</div><div class="line">    </div><div class="line">    [viewController displayItem:itemName]; // custom method</div><div class="line">    app.applicationIconBadgeNumber = localNotif.applicationIconBadgeNumber-1;</div><div class="line"></div><div class="line">    &#125; </div><div class="line">    [window addSubview:viewController.view]; </div><div class="line">    [window makeKeyAndVisible]; </div><div class="line">    return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>远程通知的实现也是类似的，除了你必须在每个平台定义一个常量作为键来访问通知的<code>payload</code>以外：</p>
<ul>
<li>在iOS中，在应用代理的<code>application:didFinishLaunchingWithOptions:</code>方法中使用<code>UIApplicationLaunchOptionsRemoteNotificationKey</code>键来获取<code>options</code>字典中的通知的<code>payload</code>。</li>
<li>在OS X中，在应用代理的<code>applicationDidFinishLaunching:</code>方法中使用<code>NSApplicationLaunchUserNotificationKey</code>键从传入的<code>NSNotification</code>对象的<code>userInfo</code>属性中获取<code>payload</code>字典。</li>
</ul>
<p><code>payload</code>是一个字典包含通知的<code>alert</code>消息，<code>badge number</code>,和声音等等。它也能包含应用程序用来设置初始的用户界面时的自定义数据。</p>
<blockquote>
<p>重要提示：远程通知的交付没有保证，所以你不应该使用通知来传递敏感数据或不能用其他方式获得得数据。</p>
</blockquote>
<p>当在应用代理的方法中处理远程通知时，应用代理会执行额外的任务。在应用启动后，代理应该和服务器连接然后下载数据。</p>
<blockquote>
<p>注意：客户端应用应该总是和服务器异步或者在次要线程通信。</p>
</blockquote>
<p>下面的代码显示了应用在前台运行时<code>application:didReceiveLocalNotification:</code>方法的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (void)application:(UIApplication *)app didReceiveLocalNotification: (UILocalNotification *)notif &#123;</div><div class="line"></div><div class="line">    NSString *itemName = [notif.userInfo objectForKey:ToDoItemKey]; </div><div class="line">    [viewController displayItem:itemName]; // custom method </div><div class="line">    app.applicationIconBadgeNumber = notification.applicationIconBadgeNumber - 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果你想在应用在前台运行时获取远程通知，你应该实现<code>application:didReceiveRemoteNotification:fetchCompletionHandler:</code>方法。</p>
<h1 id="触发基于位置的本地通知"><a href="#触发基于位置的本地通知" class="headerlink" title="触发基于位置的本地通知"></a>触发基于位置的本地通知</h1><p>在<code>iOS8</code>和之后的系统中，可以创建基于地理位置的本地通知。当用户到达特定的地理位置区域时可以触发本地通知。<code>UILocalNotification</code>对象可以用一个<code>Core Location region</code>实例来配置。当用户进入或者离开时会触发相应的本地通知。你可以配置只触发一次或者在用户每次进入或离开时都触发本地通知。</p>
<h2 id="注册基于位置的本地通知"><a href="#注册基于位置的本地通知" class="headerlink" title="注册基于位置的本地通知"></a>注册基于位置的本地通知</h2><p>基于地理位置的本地通知需要应用支持<code>Core Location</code>。你必须配置一个<code>CLLocationManager</code>和对应的代理，然后向用户请求定位服务。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">CLLocationManager *locMan = [[CLLocationManager alloc] init]; </div><div class="line">// Set a delegate that receives callbacks that specify if your app is allowed to track the user&apos;s location </div><div class="line">locMan.delegate = self;</div><div class="line"></div><div class="line">// Request authorization to track the user’s location and enable location-based local notifications </div><div class="line">[locMan requestWhenInUseAuthorization];</div></pre></td></tr></table></figure></p>
<p>当你第一次申请定位服务时，<code>iOS</code>会请求用户同意或者拒绝应用的定位服务。<code>iOS</code>会使用<code>Info.plist</code>文件中<code>NSLocationWhenInUseUsageDescription</code>键所对应的文本来显示说明文字。如果要启动定位服务一定要包含这个键，否则<code>iOS</code>不会启动定位服务。</p>
<p>当应用在后台或者被挂起时，用户可能也可以看到基于地理位置的本地通知。然而，应用并不会收到任何回调，直到用户与<code>alert</code>交互应用才被允许获取用户的位置。</p>
<h2 id="处理地理位置回调"><a href="#处理地理位置回调" class="headerlink" title="处理地理位置回调"></a>处理地理位置回调</h2><p>在应用启动时，你应该检查位置通知的授权状态以此开启或者关闭位置通知。你必须处理的从<code>Core Location</code>返回的代理回调是<code>locationManager:didChangeAuthorizationStatus:</code>，这个方法里面会告诉你授权的状态。首先，通过回调中<code>kCLAuthorizationStatusAuthorizedWhenInUse</code>检查授权状态－－这意味着你的应用被允许来跟踪用户的位置。然后你就可以开始安排你的本地通知了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (void)locationManager:(CLLocationManager *)manager didChangeAuthorizationStatus:(CLAuthorizationStatus)status &#123;</div><div class="line"></div><div class="line">    // Check status to see if the app is authorized </div><div class="line">    BOOL canUseLocationNotifications = (status ==  </div><div class="line">    kCLAuthorizationStatusAuthorizedWhenInUse);</div><div class="line"></div><div class="line">    if (canUseLocationNotifications) &#123;</div><div class="line"></div><div class="line">        [self startShowingLocationNotifications]; // Custom method defined below </div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面的代码展示了如何创建一个基于地理位置的通知。就像普通的本地通知一样，你首先得创建一个<code>UILocalNotification</code>对象然后设置它的类型，这个例子中是一个<code>alert</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (void)startShowingNotifications &#123;</div><div class="line"></div><div class="line">    UILocalNotification *locNotification = [[UILocalNotification alloc] init];</div><div class="line">    locNotification.alertBody = @“You have arrived!”;</div><div class="line">    locNotification.regionTriggersOnce = YES;</div><div class="line"></div><div class="line">    locNotification.region = [[CLCircularRegion alloc] initWithCenter:LOC_COORDINATE          radius:LOC_RADIUS </div><div class="line">    identifier:LOC_IDENTIFIER];</div><div class="line"></div><div class="line">    [[UIApplication sharedApplication] scheduleLocalNotification:locNotification];</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>假设应用不在前台运行当用户到达上面代码指定的区域时，iOS会显示一个警告:”你已经到了”。下面一行指定当用户进入或离开此区域时警报只在第一次显示。这是默认的行为。但是如果对于应用来说必须每次都显示，就可以把它设置为<code>NO</code>。</p>
<p>然后，你创建了一个<code>CLCircularRegion</code>对象，并把它设置到<code>UILocalNotification</code>对象的<code>origin</code>属性。这个例子中我们使用了<code>CLCircularRegion</code>但是你也可以使用<code>CLBeaconRegion</code>或者任何<code>CLRegion</code>的子类。</p>
<p>最后，在<code>UIApplication</code>上调用<code>scheduleLocalNotification</code>来派发这个通知。</p>
<h2 id="处理基于位置的通知"><a href="#处理基于位置的通知" class="headerlink" title="处理基于位置的通知"></a>处理基于位置的通知</h2><p>假设应用被挂起时用户进入了上面指定的位置，一个显示”你来了”的警报会显示出来。你可以在<code>application:didFinishLaunchingWithOptions:</code>方法里面处理本地通知，或者当用户进入指定的区域时你的应用在前台运行，你的应用代理会收到<code>application:didReceiveLocalNotification:</code>消息。</p>
<p>处理位置通知的逻辑对于<code>application:didFinishLaunchingWithOptions:</code>和<code>application:didReceiveLocalNotification:</code>非常相似。这两个方法都会提供一个有<code>origin</code>属性的本地通知，如果<code>origin</code>属性不为<code>nil</code>，那么这就是一个位置通知。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (void)application:(UIApplication *)application didReceiveLocalNotification: (UILocalNotification *)notification &#123;</div><div class="line"></div><div class="line">    CLRegion *region = notification.region;</div><div class="line">    if (region) &#123;</div><div class="line"></div><div class="line">        [self tellFriendsUserArrivedAtRegion:region]; </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后，请记住当用户取消应用的定位授权时<code>application:didReceiveLocalNotification:</code>方法不会被调用。</p>
<h1 id="准备自定义的警报声音"><a href="#准备自定义的警报声音" class="headerlink" title="准备自定义的警报声音"></a>准备自定义的警报声音</h1><p>对于iOS中的远程通知，你可以指定自定义的声音当iOS显示本地或远程通知时播放这个声音。声音文件可以在应用的主<code>bundle</code>中，也可以在应用的数据容器的<code>Library/Sound</code>文件夹中。<br>自定义的声音由iOS的音频硬件播放出来，所以必须是下面的格式：</p>
<ul>
<li><strong><code>Linear PCM</code></strong></li>
<li><strong><code>MA4(IMA/IDPCM)</code></strong></li>
<li><strong><code>μLaw</code></strong></li>
<li><strong><code>aLaw</code></strong></li>
</ul>
<p>你可以使用<code>aiff</code>,<code>wav</code>,<code>caf</code>打包声音文件。然后在<code>Xcode</code>中添加这些声音文件到<code>bundle</code>或者到<code>Library/Sound</code>目录。</p>
<p>你可以使用<code>afconvert</code>来转换不同的音频文件。例如，可以使用下面的命令来把<code>16</code>位的<code>linear PCM</code>的系统声音<code>Submarine.aiff</code>转化为<code>CAF</code>文件格式的<code>IMA4</code>音频：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">afconvert /System/Library/Sounds/Submarine.aiff ~/Desktop/sub.caf -d ima4 -f caff -v</div></pre></td></tr></table></figure></p>
<p>可以通知把声音文件在<code>Quick Player</code>中打开然后使用<code>Show Movie Inspector</code>来检查音频的格式。</p>
<p>自定义的声音不能超过30s，如果超过这个限制，iOS不会使用这个音频文件而使用默认的系统声音来播放。</p>
<h1 id="传给服务器当前设备的语言选项"><a href="#传给服务器当前设备的语言选项" class="headerlink" title="传给服务器当前设备的语言选项"></a>传给服务器当前设备的语言选项</h1><p>如果应用程序不使用远程通知的<code>aps</code>字典中的<code>loc-key</code>和<code>loc-args</code>来获取本地化的警告消息，那么服务器需要提前本地化通知中的警报消息。要做到这一点，服务器需要知道设备的当前语言选项。然后应用需要传给服务器一个当前语言的标示，如<code>en</code>或者<code>fr</code>。</p>
<p>下面的代码展示了如何获取当前的语言并回穿给服务器。在iOS中，<code>NSLocale</code>的<code>preferredLanguages</code>属性一个只包含一个对象的数组：一个<code>NSString</code>对象表示当前的语言选项。<code>UTF8String</code>使用<code>utf-8</code>编码把该字符串转换成<code>c</code>字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSString *preferredLang = [[NSLocale preferredLanguages] objectAtIndex:0]; </div><div class="line">const char *langStr = [preferredLang UTF8String];</div><div class="line">[self sendProviderCurrentLanguage:langStr]; // custom method </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>应用需要在用户每次改变语言设置时都把语言选项发送给服务器。通过监听<code>NSCurrentLocaleDidChangeNotification</code>通知然后在回调中得到语言标示然后传给服务器，可以做到这一点。</p>
<p>如果设备的语言并不是应用支持的语言，服务器需要一种广泛使用的语言来本地化警告消息文本，如英语或西班牙语。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;应用程序必须进行适当配置，才可以接受本地或远程通知。配置过程在&lt;code&gt;iOS&lt;/code&gt;和&lt;code&gt;OS X&lt;/code&gt;略有不同，但基本原理是相同的。在启动时，您的应用程序注册接收通知，并与系统配合来配置通知支持。一旦注册完成，可以开始传递给你的应用程序创建的通知。然后，您的应用程序处理这些收到的通知，并提供相应的响应。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;IOS&lt;/code&gt;和&lt;code&gt;tvOS&lt;/code&gt;，注册通知被分成两个部分：注册所支持的用户交互和注册通知自己。注册您的应用程序支持的用户交互类型来告诉操作系统要如何通知用户当一个通知到达时。本地或远程通知都需要此步骤。对于远程通知，必须执行注册的第二步来获得&lt;code&gt;APNs&lt;/code&gt;用于传送通知的应用程序特定的设备&lt;code&gt;token&lt;/code&gt;。 （对于本地通知，没有第二个注册步骤。）在&lt;code&gt;OS X&lt;/code&gt;中，仅支持远程通知应用程序才需要注册。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS push notification part one</title>
    <link href="http://guopp.me/2016/08/27/iOS-push-notification-part-one/"/>
    <id>http://guopp.me/2016/08/27/iOS-push-notification-part-one/</id>
    <published>2016-08-27T06:37:24.000Z</published>
    <updated>2016-08-27T06:49:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>本地通知和远程通知是用户通知(<code>user notification</code>)的两种类型，它们不同于广播通知（由<code>NSNotificationCenter</code>类管理）和键值观察通知(<code>key - value obverse</code> )。即使<code>app</code>没有在前台运行，用户通知也能让用户知道有关于他们的新消息。该信息可以是简单的一条关于用户的消息，或者是即将发生的日程表事件，或者是远程服务器上新的数据。当操作系统呈现用户通知时，无论是来自本地的还是远程的通知，它们的展现形式都是一样的。他们可以显示警告信息，也可以在应用图标上显示<code>badge</code>，或者同时播放声音。</p>
<a id="more"></a>
<p>本地通知和远程通知是用户通知(<code>user notification</code>)的两种类型，它们不同于广播通知（由<code>NSNotificationCenter</code>类管理）和键值观察通知(<code>key - value obverse</code> )。即使<code>app</code>没有在前台运行，用户通知也能让用户知道有关于他们的新消息。该信息可以是简单的一条关于用户的消息，或者是即将发生的日程表事件，或者是远程服务器上新的数据。当操作系统呈现用户通知时，无论是来自本地的还是远程的通知，它们的展现形式都是一样的。他们可以显示警告信息，也可以在应用图标上显示<code>badge</code>，或者同时播放声音。</p>
<p>当收到用户通知时，用户可以点击它来启动相关的应用程序，查看详细信息。他们也可以选择忽略该通知，在这种情况下，该应用不会被激活。</p>
<p>本地和远程通知的根本目的是使应用程序不在前台运行时也能提醒用户有关于他们的新消息。例如–一封新邮件或即将到来的约会。本地通知和远程通知的本质区别很简单︰</p>
<ul>
<li>本地通知由一个应用程序在同一个设备上生成和传递。</li>
<li>远程通知，也被称为推送通知，由你的服务器发送到苹果推送通知服务(<code>Apple Push Notification service</code>)，然后由<code>APNS</code>向设备推送通知。</li>
</ul>
<h1 id="本地和远程通知对用户的表现形式是一样的"><a href="#本地和远程通知对用户的表现形式是一样的" class="headerlink" title="本地和远程通知对用户的表现形式是一样的"></a>本地和远程通知对用户的表现形式是一样的</h1><p>用户可以通过下面的几种方式得到通知：</p>
<ul>
<li>屏幕上的<code>alert</code>或<code>banner</code></li>
<li>应用程序的图标的<code>badge</code></li>
<li>伴随<code>alert</code>，<code>banner</code>，<code>badge</code>的声音</li>
</ul>
<p>从用户的角度看本地和远程的通知表明在应用程序里面有用户感兴趣的东西。</p>
<p>例如，有一个管理待办事项应用程序，在列表中的每个项目都有一个必须完成的项目的日期和时间。用户可以要求应用程序在该日期到来前的一个特定的时间间通知它。要实现此行为，应用程序生成一个关于这个日期和时间的本地通知。该应用选择指定一个<code>badge（1）</code>和播放一个声音，而不是显示一个<code>alert</code>。届时，iOS设备播放的声音，在应用程序的图标的右上角显示一个<code>1</code>。如下图：<br><img src="http://7xvudw.com1.z0.glb.clouddn.com/Screen%20Shot%202016-08-17%20at%2015.08.28.png" alt=""></p>
<p>用户听到的声音和看到<code>badge</code>，并启动应用程序，查看待办事项。用户指定设备上的哪些<code>app</code>可以发送通知，他们也可以对某些<code>app</code>启用或者禁用某些通知类型（即<code>alert</code>,<code>badge</code>,<code>sound</code>）。</p>
<h1 id="本地和远程通知对于app来说是不一样的"><a href="#本地和远程通知对于app来说是不一样的" class="headerlink" title="本地和远程通知对于app来说是不一样的"></a>本地和远程通知对于<code>app</code>来说是不一样的</h1><p>当你的应用程序是在前台运行时，UIKit直接把本地和远程通知传递到应用程序的委托对象，而不显示任何系统UI。对于收到的本地通知， UIKit调用<code>application：didReceiveLocalNotification：</code>方法,而对于远程通知则调用<code>application：didReceiveRemoteNotification：fetchCompletionHandler：</code>方法。使用提供的通知字典来更新你的应用。因为你的应用程序正在运行，你可以悄悄的更新你的用户界面，让用户知道有新的信息。</p>
<p>当你的应用程序必须启动以接收通知，<code>UIKit</code>将包括<code>UIApplicationLaunchOptionsLocalNotificationKey</code>或<code>UIApplicationLaunchOptionsRemoteNotificationKey</code>的键的词典传递给你的应用程序委托的<code>application：willFinishLaunchingWithOptions：</code>和<code>application：didFinishLaunchingWithOptions：</code>方法。这些键的存在可以让你知道有通知数据等待被处理，并给你一个机会，以适当地配置你的应用程序的界面。你不需要在这些方法中处理通知。在你的应用程序运行后，UIKit调用你的应用程序委托的其他方法，如<code>application：didReceiveLocalNotification</code>方法，来让你处理通知数据。哪个方法被调用取决于你的实现和用户与系统<code>UI</code>的交互。</p>
<p>当你的应用程序正在运行，但不是最前端，<code>UIKit</code>显示系统<code>UI</code>，然后传递结果到后台运行的<code>app</code>。和正在运行的<code>app</code>类似，<code>UIKit</code>调用相关的方法来处理通知。如果无法在后台交付通知数据，<code>UIKit</code>的等待你的应用程序下一次运行的时候再传递通知数据。</p>
<h1 id="本地通知"><a href="#本地通知" class="headerlink" title="本地通知"></a>本地通知</h1><p>本地通知非常适合应用与基于时间的行为，如日历和待办事项列表的应用程序。在后台长时间运行的程序而被<code>iOS</code>系统限制的<code>app</code>可能会发现本地通知也有用。例如，依赖于服务器消息或数据的应用程序可以轮询服务器传人的新消息当<code>app</code>在后台运行时;如果有新消息或更新可以下载，它们就可以处理需要的数据，并在适当的时候通知用户。</p>
<p>本地通知是<code>UILocalNotification</code>或<code>NSUserNotification</code>的实列并有三种不用类型的属性：</p>
<ul>
<li><strong>Scheduled time</strong><br>您必须指定操作系统传递通知的日期和时间;这个被称为<code>fire date</code>。可以限定<code>fire date</code> 的时区，这样当用户旅行时系统可以调整触发时间。你也可以要求系统以一个固定的间隔（周，月，等待）来触发通知。</li>
<li><strong>Notification type</strong><br>这些属性包括警报消息，默认的动作按钮的标题，应用程序图标<code>badge</code>数量，要播放的声音，以及1<code>iOS8</code>和更高版本的自定义动作的类别。</li>
<li><strong>Custom data</strong><br>本地通知包含的用户信息字典的自定义数据。</li>
</ul>
<p>设备上的每个应用程序被限制为最多64个本地通知。系统会丢弃超过此限制的通知，只保留最近要触发的64个通知。重复通知被视为一个单个的通知。</p>
<h1 id="远程通知"><a href="#远程通知" class="headerlink" title="远程通知"></a>远程通知</h1><p>iOS或Mac应用程序通常是基于客户端/服务器模式的较大的应用程序的一部分。该应用程序的客户端安装在设备或计算机上;该应用的服务器侧具有向它的客户端应用提供数据的主要功能，并且因此被称为提供者(<code>Provider</code>)。客户端应用程序会定期与服务器连接并下载正在等待它的任何数据。电子邮件和社交网络应用程序是该客户端/服务器模型的例子。</p>
<p>但是，如果应用程序没有连接到提供者，甚至当应用程序正在在设备或计算机上运行时，提供者有新的数据等它下载？它是如何知道这个等待数据？远程通知是解决这一困境的方法。远程通知是一个提供者传递给设备的操作系统的短消息;操作系统可以通知客户端的应用程序，有数据要下载，有新的消息要浏览，等等。如果用户启用该功能（在<code>iOS</code>）并且该应用正确注册，通知被传递到操作系统和应用程式。苹果推送通知服务（<code>APNs</code>）是远程通知功能的主要技术。</p>
<p>远程通知服务和桌面系统上的后台应用程序目的差不多，但没有额外的开销。通知会在当前没有运行，或者在iOS中的情况下，没有运行在前台的应用中发生。操作系统代表应用程序接收远程通知，并提醒用户。然后，如果用户启动应用程序，它会下载服务器提供的数据。如果在应用程序正在运行时通知被传递到<code>app</code>，应用程序可以选择直接处理通知。</p>
<p>正如它的名字所暗示的，苹果推送通知服务使用一个远程的设计以传递远程通知到设备和计算机。推式设计(<code>push design</code>)不同于它的反面拉式的设计(<code>pull design</code>)，该通知的收件人被动侦听更新，而不是积极地轮询。<code>APNs</code>使用持久<code>IP</code>连接来实现远程通知。</p>
<p>大多数远程通知包含一个<code>payload</code>：一个<code>JSON</code>字典包含已经定义好的如何通知用户的<code>APNs</code>属性。<code>payload</code>越小，通知的性能越好。虽然你可以定义自定义属性，但是不要用远程通知机制来传输数据。远程通知是尽最大努力交付，这具有很高的成功率，但不能保证每次都成功。</p>
<p>当一台设备不在线时，<code>APNs</code>保留上次从该设备上的应用程序的提供者收到的通知。如果该设备上线（联网），<code>APNs</code>会把存储的通知推送到设备。运行<code>iOS</code>的设备接收通过<code>Wi-Fi</code>和蜂窝连接的远程通知;一台运行OS X通过<code>Wi-Fi</code>和以太网连接，接收远程通知。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本地通知和远程通知是用户通知(&lt;code&gt;user notification&lt;/code&gt;)的两种类型，它们不同于广播通知（由&lt;code&gt;NSNotificationCenter&lt;/code&gt;类管理）和键值观察通知(&lt;code&gt;key - value obverse&lt;/code&gt; )。即使&lt;code&gt;app&lt;/code&gt;没有在前台运行，用户通知也能让用户知道有关于他们的新消息。该信息可以是简单的一条关于用户的消息，或者是即将发生的日程表事件，或者是远程服务器上新的数据。当操作系统呈现用户通知时，无论是来自本地的还是远程的通知，它们的展现形式都是一样的。他们可以显示警告信息，也可以在应用图标上显示&lt;code&gt;badge&lt;/code&gt;，或者同时播放声音。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS push notification part three</title>
    <link href="http://guopp.me/2016/08/26/iOS-push-notification-part-three/"/>
    <id>http://guopp.me/2016/08/26/iOS-push-notification-part-three/</id>
    <published>2016-08-26T12:03:42.000Z</published>
    <updated>2016-08-27T08:10:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>苹果的远程推送通知服务(<code>APNs</code>)是远程通知的核心。这是一个强健并且高效的系统来为<code>iOS</code>，<code>watchOS</code>，<code>tvOS</code>设备推送消息。每台设备都和<code>APNs</code>建立了一个加密的可信<code>IP</code>链接，通过这个持久的链接来接收<code>APNs</code>发送给设备的消息。如果通过这个链接发送到设备后，相应的应用不在前台运行，系统会展示相应的警告框提示用户。</p>
<p>你需要使用自己的服务器来为用户生成远程通知。这个服务器被称为<code>Provider</code>，它生成远程通知的数据并且决定什么时候推送这个远程通知。对于每个远程通知，<code>Provider</code>生成通知的<code>payload</code>然后使用<code>HTTP/2</code>的持久的加密链接发送到<code>APNs</code>，<code>APNs</code>负责把通知推送到用户设备。</p>
<a id="more"></a>
<p>苹果的远程推送通知服务(<code>APNs</code>)是远程通知的核心。这是一个强健并且高效的系统来为<code>iOS</code>，<code>watchOS</code>，<code>tvOS</code>设备推送消息。每台设备都和<code>APNs</code>建立了一个加密的可信<code>IP</code>链接，通过这个持久的链接来接收<code>APNs</code>发送给设备的消息。如果通过这个链接发送到设备后，相应的应用不在前台运行，系统会展示相应的警告框提示用户。</p>
<p>你需要使用自己的服务器来为用户生成远程通知。这个服务器被称为<code>Provider</code>，它生成远程通知的数据并且决定什么时候推送这个远程通知。对于每个远程通知，<code>Provider</code>生成通知的<code>payload</code>然后使用<code>HTTP/2</code>的持久的加密链接发送到<code>APNs</code>，<code>APNs</code>负责把通知推送到用户设备。</p>
<h1 id="远程通知的路径"><a href="#远程通知的路径" class="headerlink" title="远程通知的路径"></a>远程通知的路径</h1><p><code>APNs</code>负责分发你的<code>Provider</code>传过来的通知到你的应用的用户的设备。当你的<code>Provider</code>需要推送一个通知，它把这个通知和设备的<code>token</code>一起发送到<code>APNs</code>。<code>APNs</code>会把这个通知传递到用户设备，设备上的操作系统会负责传递这个通知到相应的应用程序。如下图：<br><img src="http://7xvudw.com1.z0.glb.clouddn.com/Screen%20Shot%202016-08-26%20at%2016.53.28.png" alt=""></p>
<p>你传给服务器的设备<code>token</code>和手机号是类似的。它包含设备的信息，<code>APNs</code>使用这个<code>token</code>能定位你的应用程序安装的设备。<code>APNs</code>也会用它来验证通知发送的过程中的路由信息。通过注册远程通知服务，系统会发送设备的<code>token</code>给你的应用程序。</p>
<p>通知的<code>payload</code>是你想发送给设备的数据，它是一个<code>JSON</code>字典。<code>payload</code>包含系统提示用户的方式，如警告框，<code>badge</code>,声音。它也能包括你自定义的数据。</p>
<p>下图展示了<code>APNs</code>在设备和<code>Provider</code>之间的虚拟网络。在<code>APNs</code>的两边－－设备方和<code>APNs</code>和<code>Provider</code>方和<code>APNs</code>之间－－都会有多个连接。在<code>Provider</code>和<code>APNs</code>的这边，它们被称为网关。通常都会有多个<code>Provider</code>,每个<code>Provier</code>都通过网关和<code>APNs</code>建立一个或多个持久的加密连接。这些<code>Provider</code>通过<code>APNs</code>发送通知到它们的客户端设备上。<br><img src="http://7xvudw.com1.z0.glb.clouddn.com/Screen%20Shot%202016-08-26%20at%2017.47.07.png" alt=""></p>
<h1 id="推送服务质量"><a href="#推送服务质量" class="headerlink" title="推送服务质量"></a>推送服务质量</h1><p><code>APNs</code>默认包含一个存储和转发功能的组件。如果要推送的设备不在线，要推送的通知会被<code>APNs</code>暂存一段时间，当设备上线之后会推送到设备。但是只有一个通知会被暂存。当有多个通知推送到设备而设备此时不在线时，最新的一个通知会被暂存，而以前的通知会被丢弃。这被称为通知合并。</p>
<p>如果设备长时间离线，那么所有的通知都会被丢弃。</p>
<h2 id="安全架构"><a href="#安全架构" class="headerlink" title="安全架构"></a>安全架构</h2><p>为了保证安全的通信，<code>APNs</code>使用两种不同的信任级别在<code>Porvider</code>和设备之间：<code>connection trust</code>和<code>token trust</code>。</p>
<p><code>Connection trust</code>保障<code>APNs</code>是连接到一个被授权可以推送通知的<code>Provider</code>上。<code>APNs</code>也会使用<code>connection trust</code>来连接到设备以保证设备的合法性。<code>APNs</code>到设备的可信连接是<code>APNs</code>自动处理的，但是<code>Provider</code>到<code>APNs</code>之间的可信连接必须要你自己负责。</p>
<p><code>Token trust</code>确保通知是在合法的起始点和终止点之间传送。<code>Token trust</code>涉及到设备<code>token</code>的使用，这是分配给特定设备上的特定应用的标识符。每个应用通过注册远程通知服务来获取它的唯一设备标识符，而且必须要把这个标识符传到服务器。因此，这个标识符应该和通知一同被<code>Provider</code>发送到<code>APNs</code>。提供这个标识符用于传递通知到特定的设备上的特定应用程序。</p>
<blockquote>
<p>注意：设备标识符并不能用来区分设备的唯一性。</p>
</blockquote>
<p><code>APNs</code>也会使用必要的证书，CA证书和密钥（公钥和私钥）来验证<code>Provider</code>和设备之间的连接。</p>
<h2 id="Provider到APNs之间的可信连接"><a href="#Provider到APNs之间的可信连接" class="headerlink" title="Provider到APNs之间的可信连接"></a><code>Provider</code>到<code>APNs</code>之间的可信连接</h2><p>每个<code>Provider</code>都必须要有一个唯一的证书和私钥，<code>APNs</code>会使用它们来验证它和<code>Provider</code>之间的连接。<code>Provider</code>的证书标示它所支持的应用的<code>bundle id</code>。</p>
<p>你的<code>Provider</code>通过<code>TLS</code>的对等网络建立可信连接到<code>APNs</code>。当<code>TLS</code>连接初始化后，你会得到<code>APNs</code>的服务端证书，然后在你这边验证证书。然后你发送你的<code>Provider</code>证书给<code>APNs</code>，<code>APNs</code>也会在它那边验证你的证书。当这个过程完成后，一个安全和可信的<code>TLS</code>就被合法的<code>Provider</code>建立了。<br><img src="http://7xvudw.com1.z0.glb.clouddn.com/Screen%20Shot%202016-08-26%20at%2019.52.08.png" alt=""></p>
<h2 id="APNs到设备的可信连接"><a href="#APNs到设备的可信连接" class="headerlink" title="APNs到设备的可信连接"></a><code>APNs</code>到设备的可信连接</h2><p>每个设备都有一个设备证书和私钥。它们用来验证和<code>APNs</code>之间的连接。设备在激活的时候会获取这个证书和私钥然后把它们保存在钥匙串中。</p>
<p>你不需要做任何事来建立<code>APNs</code>和设备之间的可信连接。<code>APNs</code>会通过<code>TLS</code>来建立到设备的可信连接。在这种情况下，设备初始化<code>TLS</code>连接，<code>APNs</code>返回服务器证书.设备验证这个证书然后发送自己的设备证书给<code>APNs</code>,<code>APNs</code>验证这个证书。<br><img src="http://7xvudw.com1.z0.glb.clouddn.com/Screen%20Shot%202016-08-26%20at%2020.01.19.png" alt=""></p>
<h2 id="Token的生成和发送"><a href="#Token的生成和发送" class="headerlink" title="Token的生成和发送"></a><code>Token</code>的生成和发送</h2><p>设备想要收到远程通知必须先在系统中注册远程通知服务。当系统收到应用的注册请求时会把这个请求转发到<code>APNs</code>。<code>APNs</code>会使用设备的证书中的信息为应用生成一个唯一的设备<code>token</code>，然后加密这个<code>token</code>再把它返回给设备。系统通过<code>NSData</code>把设备<code>token</code>传递给应用。当收到这个设备<code>token</code>后，应用应该使用二进制或者十六进制把这个<code>token</code>发送给你的服务器。服务器不能把通知推送到没用这个<code>token</code>的设备。流程如下图：<br><img src="http://7xvudw.com1.z0.glb.clouddn.com/Screen%20Shot%202016-08-27%20at%2016.00.07.png" alt=""></p>
<blockquote>
<p><code>APNs</code>的设备<code>token</code>长度是可变的。不要写死长度。</p>
</blockquote>
<p>下图显示设备<code>token</code>的生成和转发路径，还有上传到<code>Provider</code>的部分。<br><img src="http://7xvudw.com1.z0.glb.clouddn.com/Screen%20Shot%202016-08-27%20at%2016.04.15.png" alt=""></p>
<h2 id="Token-Trust-Notification"><a href="#Token-Trust-Notification" class="headerlink" title="Token Trust (Notification)"></a>Token Trust (Notification)</h2><p>每个从<code>Provider</code>发送给<code>APNs</code>的远程通知都必须和<code>device token</code>一起发送。<code>APNs</code>使用它的<code>token key</code>解密通知中的<code>token</code>来确保<code>Provider</code>的合法性。然后使用<code>device token</code>中的<code>device ID</code>来决定推送的目标设备，最后把这个通知推送给目标设备。<br><img src="http://7xvudw.com1.z0.glb.clouddn.com/Screen%20Shot%202016-08-27%20at%2016.08.56.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;苹果的远程推送通知服务(&lt;code&gt;APNs&lt;/code&gt;)是远程通知的核心。这是一个强健并且高效的系统来为&lt;code&gt;iOS&lt;/code&gt;，&lt;code&gt;watchOS&lt;/code&gt;，&lt;code&gt;tvOS&lt;/code&gt;设备推送消息。每台设备都和&lt;code&gt;APNs&lt;/code&gt;建立了一个加密的可信&lt;code&gt;IP&lt;/code&gt;链接，通过这个持久的链接来接收&lt;code&gt;APNs&lt;/code&gt;发送给设备的消息。如果通过这个链接发送到设备后，相应的应用不在前台运行，系统会展示相应的警告框提示用户。&lt;/p&gt;
&lt;p&gt;你需要使用自己的服务器来为用户生成远程通知。这个服务器被称为&lt;code&gt;Provider&lt;/code&gt;，它生成远程通知的数据并且决定什么时候推送这个远程通知。对于每个远程通知，&lt;code&gt;Provider&lt;/code&gt;生成通知的&lt;code&gt;payload&lt;/code&gt;然后使用&lt;code&gt;HTTP/2&lt;/code&gt;的持久的加密链接发送到&lt;code&gt;APNs&lt;/code&gt;，&lt;code&gt;APNs&lt;/code&gt;负责把通知推送到用户设备。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
