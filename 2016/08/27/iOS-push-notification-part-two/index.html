<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> iOS push notification part two · guopp</title><meta name="description" content="iOS push notification part two - guopp"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://guopp.me/atom.xml" title="guopp"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a target="_self" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a target="_self" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">iOS push notification part two</h1><div class="post-info">2016年8月27日</div><div class="post-content"><p>应用程序必须进行适当配置，才可以接受本地或远程通知。配置过程在<code>iOS</code>和<code>OS X</code>略有不同，但基本原理是相同的。在启动时，您的应用程序注册接收通知，并与系统配合来配置通知支持。一旦注册完成，可以开始传递给你的应用程序创建的通知。然后，您的应用程序处理这些收到的通知，并提供相应的响应。</p>
<p>在<code>IOS</code>和<code>tvOS</code>，注册通知被分成两个部分：注册所支持的用户交互和注册通知自己。注册您的应用程序支持的用户交互类型来告诉操作系统要如何通知用户当一个通知到达时。本地或远程通知都需要此步骤。对于远程通知，必须执行注册的第二步来获得<code>APNs</code>用于传送通知的应用程序特定的设备<code>token</code>。 （对于本地通知，没有第二个注册步骤。）在<code>OS X</code>中，仅支持远程通知应用程序才需要注册。</p>
<a id="more"></a>
<p>应用程序必须进行适当配置，才可以接受本地或远程通知。配置过程在<code>iOS</code>和<code>OS X</code>略有不同，但基本原理是相同的。在启动时，您的应用程序注册接收通知，并与系统配合来配置通知支持。一旦注册完成，可以开始传递给你的应用程序创建的通知。然后，您的应用程序处理这些收到的通知，并提供相应的响应。</p>
<p>在<code>IOS</code>和<code>tvOS</code>，注册通知被分成两个部分：注册所支持的用户交互和注册通知自己。注册您的应用程序支持的用户交互类型来告诉操作系统要如何通知用户当一个通知到达时。本地或远程通知都需要此步骤。对于远程通知，必须执行注册的第二步来获得<code>APNs</code>用于传送通知的应用程序特定的设备<code>token</code>。 （对于本地通知，没有第二个注册步骤。）在<code>OS X</code>中，仅支持远程通知应用程序才需要注册。</p>
<h1 id="注册通知支持的用户交互类型"><a href="#注册通知支持的用户交互类型" class="headerlink" title="注册通知支持的用户交互类型"></a>注册通知支持的用户交互类型</h1><p>在<code>iOS8</code>和更高版本的系统中，使用本地或远程通知的应用必须注册该应用程序支持的用户交互类型。应用程序可以要求图标<code>badge</code>，显示警告信息，或播放声音。当您请求这些互动类型的时候，应该先查看该用户已允许什么类型的交互。如果用户不允许某个特定类型的交互，系统将忽略尝试以这种方式与用户进行交互。例如，如果一个通知要显示警告信息，并播放声音，而用户不允许声音，系统会显示警告信息，但不播放声音。</p>
<p>要注册您的应用程序支持的交互类型，调用<code>registerUserNotificationSettings：</code>方法。使用<code>setting object</code>来指定应用程序是否<code>badge</code>图标，是否显示警告信息，或播放声音。如果你不要求任何交互类型，系统悄悄的推送所有通知到你的应用程序。下面的代码显示了支持显示警报消息，并播放声音的应用程序的代码段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">UIUserNotificationType types = (UIUserNotificationType) (UIUserNotificationTypeBadge |</div><div class="line">UIUserNotificationTypeSound | UIUserNotificationTypeAlert);</div><div class="line">UIUserNotificationSettings *mySettings = [UIUserNotificationSettings settingsForTypes:types categories:nil];</div><div class="line">[[UIApplication sharedApplication] registerUserNotificationSettings:mySettings];</div></pre></td></tr></table></figure></p>
<p>除了注册您的应用程序的交互类型，应用程序可以注册一个或多个类别。类别都支持本地和远程通知，并使用它们来标识通知的目的。你的<code>iOS</code>应用程序可以使用类别标识符来决定如何处理通知。在<code>watchOS</code>，类别也被用来定制显示给用户的通知接口。</p>
<p>从<code>iOS8</code>开始，你可以选择通过注册自定义动作的通知类型创建可以执行动作的通知。当一个可执行的通知到达时，系统会为每个注册的操作添加按钮，并添加这些按钮到通知界面。这些操作按钮是用户能够执行相关通知任务的快捷方式。例如，对于会议的远程通知邀请可能会提供动作来接受或拒绝该会议。当用户点击你的一个动作按钮，系统会通知你的应用程序，让你有机会可以执行相应的动作。</p>
<p>当应用程序第一次调用<code>registerUserNotificationSettings：</code>方法，<code>iOS</code>设备将提示用户允许指定的交互。在后续应用启动中，调用此方法不会提示用户。调用方法后，<code>iOS</code>异步的报告结果到<code>application：didRegisterUserNotificationSettings：</code>方法中。当你第一次注册你的设置，iOS在调用此方法之前等待用户的反应，但在随后的调用将返回现有的用户设置。</p>
<p>用户可以通过<code>Setting app</code>在任何时候改变你的应用程序通知设置。由于设置可以改变，始终调用<code>registerUserNotificationSettings：</code>在应用启动时，然后使用<code>application：didRegisterUserNotificationSettings：</code>方法来获得结果。如果用户不允许特定的通知类型，避免使用这些类型来配置你的应用程序的本地和远程通知。</p>
<h1 id="注册远程通知"><a href="#注册远程通知" class="headerlink" title="注册远程通知"></a>注册远程通知</h1><p>想要接收远程通知必须注册苹果推送通知服务（<code>APNs</code>）来获得一个<code>device token</code>。在<code>iOS8</code>和更高版本，注册包括以下步骤：</p>
<ol>
<li>在注册应用程序的支持的用户交互类型。</li>
<li>调用<code>registerForRemoteNotifications</code>方法来注册远程通知。 （在<code>OS X</code>中，使用<code>registerForRemoteNotificationTypes：</code>方法来注册你的应用程序支持交互类型并在同一步中注册远程通知。）</li>
<li>使用应用程序委托<code>application：didRegisterForRemoteNotificationsWithDeviceToken：</code>方法来接收提供远程通知所需要的<code>device token</code>。使用<code>application：didFailToRegisterForRemoteNotificationsWithError：</code>方法来处理错误。</li>
<li>如果注册成功，发送<code>device token</code>到用于生成远程通知的服务器</li>
</ol>
<blockquote>
<p><code>iOS</code>注意：如果蜂窝或Wi-Fi连接不可用，无论是<code>application：didRegisterForRemoteNotificationsWithDeviceToken：</code>方法或者<code>application：didFailToRegisterForRemoteNotificationsWithError：</code>方法都不会被调用。对于<code>Wi-Fi</code>连接，这有时会发生在设备不能超过配置端口连接到<code>APNs</code>。如果发生这种情况，用户可以通过连接到另一个不屏蔽所需端口的<code>Wi-Fi</code>网络，或者等<code>iPhone</code>或<code>iPad</code>的蜂窝数据服务变得可用。在这两种情况下，该设备应能够建立连接，然后委托方法被调用。</p>
</blockquote>
<p><code>device token</code>是将通知推送到到特定设备上的应用程序的关键。<code>Device token</code>可以改变，所以应用需要在每次启动时重新注册，并把接收到的<code>token</code>回传到你的服务器。如果无法更新设备<code>token</code>，远程通知可能不会被传递到设备。当用户将备份数据恢复到新设备或电脑，或重新安装操作系统时设备<code>token</code>总是会改变。当将数据迁移到新的设备或计算机，用户必须启动应用程序一次，从而远程通知可以传送到该设备。</p>
<p>永远不要缓存设备<code>token</code>;总是从系统中获得<code>token</code>。如果您的应用程序之前注册过远程通知，再调用<code>registerForRemoteNotifications</code>方法不会产生任何额外的开销，<code>iOS</code>会立即返回现有的设备<code>token</code>到应用程序委托。此外，iOS会随时调用你的委托方法当设备<code>token</code>变化的时候，而不是仅仅只在你的应用程序注册或重新注册远程通知的时候。</p>
<p>下面的代卖显示了如何在<code>iOS</code>应用中注册远程通知。应用程序注册支持的动作类型后，下面的方法调用<code>registerForRemoteNotifications</code>方法。在接收到设备<code>token</code>后，委托方法调用自定义代码来发送<code>token</code>到服务器。在<code>OS X</code>中，注册交互类型的方法是不同的，但是用于处理注册的委托方法是类似的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">- (void)applicationDidFinishLaunching:(UIApplication *)app &#123;</div><div class="line">    </div><div class="line">    UIUserNotificationType types = UIUserNotificationTypeBadge |  </div><div class="line">    UIUserNotificationTypeSound | UIUserNotificationTypeAlert; </div><div class="line">    UIUserNotificationSettings *mySettings = [UIUserNotificationSettings</div><div class="line">    settingsForTypes:types categories:nil]; [[UIApplication sharedApplication]</div><div class="line">    registerUserNotificationSettings:mySettings];</div><div class="line">    </div><div class="line">    // Register for remote notifications. </div><div class="line">    [[UIApplication sharedApplication] registerForRemoteNotifications];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Handle remote notification registration. </div><div class="line">- (void)application:(UIApplication *)app didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)devToken &#123; </div><div class="line"></div><div class="line">    const void *devTokenBytes = [devToken bytes];</div><div class="line">    self.registered = YES; [self sendProviderDeviceToken:devTokenBytes]; // custom method</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)application:(UIApplication *)app didFailToRegisterForRemoteNotificationsWithError:(NSError *)err &#123; </div><div class="line"></div><div class="line">    NSLog(@&quot;Error in registration. Error: %@&quot;, err); </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在<code>application︰ didFailToRegisterForRemoteNotificationsWithError︰</code>方法中，你应该适当地处理错误对象和禁用与远程通知相关的任何功能。因为通知无论如何都不会被送达，这简直不能更棒，因为不需要处理和显示这些通知。</p>
<h1 id="注册可以执行动作的通知类型"><a href="#注册可以执行动作的通知类型" class="headerlink" title="注册可以执行动作的通知类型"></a>注册可以执行动作的通知类型</h1><p>可以执行动作的通知可以让你在标准的本地和远程通知界面上添加自定义的动作按钮。可动作的通知给用户一种快速且简单的方式执行和通知相关的任务来响应通知。在<code>iOS8</code>之前，通知只有一种默认的动作。在<code>iOS8</code>之后，在锁屏界面，在通知中心的通知横幅和通知条目上都可以有一个或两个自定义的动作按钮。<code>modal alert</code> 甚至能显示四个按钮。当用户点击了其中的自定义按钮，<code>iOS</code>会通知你的应用来让你执行该按钮相关的任务。</p>
<blockquote>
<p>注意：<code>OS X</code> 并没有这种可以执行动作的通知。</p>
</blockquote>
<h2 id="定义你的可执行动作的通知"><a href="#定义你的可执行动作的通知" class="headerlink" title="定义你的可执行动作的通知"></a>定义你的可执行动作的通知</h2><p>自定义动作的配置取决于定义一个或多个类别的通知。每个类别代表应用会收到的一种类型的通知，你必须定义你的应用所支持的类别。对于每个类别中，可以定义收到该类型的通知时，用户可能采取的动作。然后，使用iOS的<code>registerUserNotificationSettings</code>注册类别，动作和应用支持的交互类型。</p>
<p>每个自定义动作包括按钮标题和iOS要显示给用户的信息当用户选择该按钮时。通过创建UIMutableUserNotificationAction类的实例并适当配置其属性来产生一个动作。下面的代码创建一个单一的“accept”动作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">UIMutableUserNotificationAction *acceptAction = [[UIMutableUserNotificationAction alloc] init];</div><div class="line">// The identifier that you use internally to handle the action. acceptAction.identifier = @&quot;ACCEPT_IDENTIFIER&quot;;</div><div class="line"></div><div class="line">// The localized title of the action button. </div><div class="line">acceptAction.title = @&quot;Accept&quot;;</div><div class="line"></div><div class="line">// Specifies whether the app must be in the foreground to perform the action. acceptAction.activationMode = UIUserNotificationActivationModeBackground;</div><div class="line"></div><div class="line">// Destructive actions are highlighted appropriately to indicate their nature. acceptAction.destructive = NO;</div><div class="line"></div><div class="line">// Indicates whether user authentication is required to perform the action. acceptAction.authenticationRequired = NO;</div></pre></td></tr></table></figure></p>
<p>创建任何自定义操作对象后，分配这些对象到<code>UIUserNotificationCategory</code>用于定义你的应用的通知类别。如果在启动时配置通知类别，通常创建<code>UIMutableUserNotificationCategory</code>类的一个实例。分配类别标识符到新的实例并使用<code>setActions：forContext：</code>方法来与该类别的自定义动作联系起来。上下文参数，可以让你对不同的系统界面制定不同的动作。默认的上下文情况支持在<code>modal alert</code>时显示四个动作。最小的<code>context</code>只支持两个动作，在锁屏界面，通知横幅，和通知中心中。</p>
<p>下面的例子显示了一个邀请的类别，其中包括来自上面代码中的<code>accept</code>按钮和两个额外的动作。在这个例子中，最小的上下文仅显示接受和拒绝按钮。如果没有指定最小上下文的动作，那么最前面的两个按钮就会被显示。按钮的顺序决定了它们在屏幕上显示的顺序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// First create the category </div><div class="line">UIMutableUserNotificationCategory *inviteCategory = [[UIMutableUserNotificationCategory alloc] init];</div><div class="line"></div><div class="line">// Identifier to include in your push payload and local notification</div><div class="line">inviteCategory.identifier = @&quot;INVITE_CATEGORY&quot;;</div><div class="line"></div><div class="line">// Set the actions to display in the default context </div><div class="line">[inviteCategory setActions:@[acceptAction, maybeAction, declineAction] forContext:UIUserNotificationActionContextDefault];</div><div class="line"></div><div class="line">// Set the actions to display in a minimal context</div><div class="line">[inviteCategory setActions:@[acceptAction, declineAction] forContext:UIUserNotificationActionContextMinimal];</div></pre></td></tr></table></figure></p>
<p>创建完通知动作类别后必须注册这些类别。应用可以注册任意数量的类别，但是每个列别必须是唯一的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSSet *categories = [NSSet setWithObjects:inviteCategory, alarmCategory, ...</div><div class="line"></div><div class="line">UIUserNotificationSettings *settings = [UIUserNotificationSettings settingsForTypes:types categories:categories];</div><div class="line">[[UIApplication sharedApplication] registerUserNotificationSettings:settings];</div></pre></td></tr></table></figure></p>
<p>通知的类型和动作的类别都是使用<code>UIUserNotificationSettings</code>的类方法<code>settingsForTypes:categories:</code>来注册，只是一个的<code>categories</code>参数为<code>nil</code>。</p>
<h2 id="触发可动作的通知"><a href="#触发可动作的通知" class="headerlink" title="触发可动作的通知"></a>触发可动作的通知</h2><p>为了显示你定义好的可动作的通知，你必须推送一个远程通知或者触发一个本地通知。在远程通知的情况下你必须在payload中包括类别的标识符（Code2-1）。对类别的支持是你的应用程序和推送服务器之间的合作完成的。当你的服务器想推送一个通知给用户，它可以在payload中添加合适的类别值。如果iOS得到一个有类别值的推送通知，它会在应用中搜索注册过的有一样值的类别，如果找到匹配的就会显示响应的动作按钮。</p>
<p>推送的payload的大小被HTTP/2提供的API限制，在2015年12月是4KB。(在2014年，Apple在遗留的二进制接口中把payload的大小限制从256字节提高到2KB)<br>Code2-1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;aps&quot;: &#123;</div><div class="line">        &quot;alert&quot;: &quot;You&apos;re invited!&quot;,</div><div class="line">        &quot;category&quot;: &quot;INVITE_CATEGORY&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在本地通知的情况下，你像平常一样创建通知，设置动作类别，然后触发通知。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">UILocalNotification *notification = [[UILocalNotification alloc] init]; </div><div class="line">. . . </div><div class="line">notification.category = @&quot;INVITE_CATEGORY&quot;; </div><div class="line">[[UIApplication sharedApplication] scheduleLocalNotification:notification];</div></pre></td></tr></table></figure></p>
<h2 id="处理可动作通知"><a href="#处理可动作通知" class="headerlink" title="处理可动作通知"></a>处理可动作通知</h2><p>如果你的应用不是在前台运行，当用户滑动或者点击通知时，<code>iOS</code>会在前台启动你的应用然后调用<code>application:didFinishLaunchingWithOptions:</code>并在<code>options</code>字典中包括本地或远程通知。在远程通知的情况下，系统还会调用<code>application:didReceiveRemoteNotification:fetchCompletionHandler:</code>。</p>
<p>如果你的应用已经在前台，<code>iOS</code>就不会显示这个通知。相反，<code>iOS</code>会调用<code>application:didReceiveLocalNotification:</code>或者<code>application:didReceiveRemoteNotification:fetchCompletionHandler:</code>。（如果你没有实现<code>application:didReceiveRemoteNotification:fetchCompletionHandler:</code>,iOS会调用<code>application:didReceiveRemoteNotification:</code>）</p>
<p>最后，为了能在<code>iOS8</code>或之后的系统里处理自定义动作，你必须实现下面两个方法中的至少一个：<code>application:handleActionWithIdentifier:forRemoteNotification:completionHandler:</code>,<code>application:handleActionWithIdentifier:forLocalNotification:completionHandler:</code>。这两张情况下你都能得到动作标识符，可以用它来确定用户点击的哪个动作。你也会得到本地或远程通知，你可以用它来获得任何关于这个动作的信息。最后系统会传递给你一个<code>completion handler</code>,当你处理完这个动作之后你必须调用这个<code>handler</code>。下面代码显示了一个自定义动作处理的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (void)application:(UIApplication *) application </div><div class="line">    handleActionWithIdentifier: (NSString *) identifier </div><div class="line">    // either forLocalNotification: (NSDictionary *) notification or</div><div class="line">    forRemoteNotification: (NSDictionary *) notification </div><div class="line">    completionHandler: (void (^)()) completionHandler &#123;</div><div class="line">    </div><div class="line">     if ([identifier isEqualToString: @&quot;ACCEPT_IDENTIFIER&quot;]) &#123;</div><div class="line">        </div><div class="line">        [self handleAcceptActionWithNotification:notification]; </div><div class="line">    &#125;</div><div class="line">        </div><div class="line">    // Must be called when finished </div><div class="line">    completionHandler();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="触发本地通知"><a href="#触发本地通知" class="headerlink" title="触发本地通知"></a>触发本地通知</h1><p>在<code>iOS</code>中,你创建一个<code>UILocalNotification</code>的实例然后使用<code>UIApplication</code>的<code>scheduleLocalNotification:</code>方法来设置通知的触发。在<code>OS X</code>中，你创建一个<code>NSUserNotification</code>的实例，然后<code>NSUserNotificationCenter</code>负责设置传递它。（<code>OS X</code>应用也可以实现<code>NSUserNotificationCenterDelegate</code>协议来自定义<code>NSUserNotificationCenter</code>的行为。）</p>
<p>在iOS中创建和触发本地通知需要你执行以下步骤：</p>
<ol>
<li>在iOS8或更高的系统版本中，需要注册通知类型。（在OS X和早期的iOS版本中，你只需要为远程通知注册通知类型）。如果你已经注册了通知类型，则可以使用<code>currentUserNotificationSettings</code>来获取用户在应用中接受的通知类型。</li>
<li>创建一个<code>UILocalNotification</code>实例。</li>
<li>设置一个系统触发通知的日期和时间。这就是<code>fireDate</code>属性。<br>如果你设置<code>timeZone</code>属性为当前语言环境的<code>NSTimeZone</code>实例，那么系统会自定调整触发时间当设备进入到不同的时区。<br>你也可以设置固定时间间隔来触发本地通知（每日，每周，每月，等等）</li>
<li>适当的配置<code>alert</code>,<code>icon badge</code>,<code>sound</code>。这样系统触发通知时就会使用这些配置来展示通知的界面。<ul>
<li><code>alert</code>有<code>message</code>，动作按钮的<code>title</code>，和<code>slider</code>(<code>alertAction</code>)属性。给它们指定一个本地化的字符串值。如果通知可以在<code>Apple Watch</code>上显示，也给<code>alertTitle</code>属性设置一个值。</li>
<li>使用<code>applicationIconBadgeNumber</code>属性来给应用的图标上设置一个<code>badge number</code>.</li>
<li>给<code>soundName</code>属性设置值来播放声音。你可以直接设置应用程序的资源包中的一个非本地化的文件名来设置属性值，也可以使用<code>UILocalNotificationDefaultSoundName</code>来获得默认的系统声音。播放声音应该和其他两种中至少一种同时作用，而不应该仅仅只是单独播放声音。</li>
</ul>
</li>
<li>另外你也可以使用<code>userInfo</code>属性为通知添加自定义的数据。例如：当一个<code>CloudKit</code>记录更改后所触发的通知中就包括这条纪录的标识符，因此<code>handler</code>就能够得到这条纪录并更新它。</li>
<li>另外在iOS8之后的系统中，本地通知也可以使用自定义可动作的通知，因此你的应用可以执行相应的动作来响应用户交互。</li>
<li>安排本地通知的交付给系统。<br>使用<code>scheduleLocalNotification:</code>来交付通知给系统。系统使用<code>UILocalNotification</code>实例中的<code>fire date</code>来触发通知。或者你也可以使用<code>presentLocalNotificationNow:</code>来立即触发这个通知。</li>
</ol>
<p>下面的代码模拟一个<code>to-do list</code>的应用在待办事件即将到来前通知用户。有几个地方需要注意，<code>alertBody</code>,<code>alertAction</code>,<code>alertTitle</code>属性都是主<code>bundle</code>中的本地化字符串。它也在<code>userInfo</code>属性中添加了待办事项的名字。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">- (void)scheduleNotificationWithItem:(ToDoItem *)item interval:(int)minutesBefore &#123;</div><div class="line"></div><div class="line">    NSCalendar *calendar = [NSCalendar autoupdatingCurrentCalendar]; </div><div class="line">    NSDateComponents *dateComps = [[NSDateComponents alloc] init]; </div><div class="line">    [dateComps setDay:item.day]; </div><div class="line">    [dateComps setMonth:item.month]; </div><div class="line">    [dateComps setYear:item.year]; </div><div class="line">    [dateComps setHour:item.hour]; </div><div class="line">    [dateComps setMinute:item.minute]; </div><div class="line">    NSDate *itemDate = [calendar dateFromComponents:dateComps];</div><div class="line"></div><div class="line">    UILocalNotification *localNotif = [[UILocalNotification alloc] init]; </div><div class="line">    if (localNotif == nil)</div><div class="line">        return; </div><div class="line">     localNotif.fireDate = [itemDate dateByAddingTimeIntervalInterval:- (minutesBefore*60)]; </div><div class="line">     localNotif.timeZone = [NSTimeZone defaultTimeZone];</div><div class="line"></div><div class="line">    localNotif.alertBody = [NSString stringWithFormat:NSLocalizedString(@&quot;%@ in %i minutes.&quot;, nil), item.eventName, minutesBefore]; </div><div class="line">    localNotif.alertAction = NSLocalizedString(@&quot;View Details&quot;, nil);</div><div class="line"></div><div class="line">    localNotif.alertTitle = NSLocalizedString(@&quot;Item Due&quot;, nil);</div><div class="line"></div><div class="line">    localNotif.soundName = UILocalNotificationDefaultSoundName;</div><div class="line"></div><div class="line">    localNotif.applicationIconBadgeNumber = 1;</div><div class="line"></div><div class="line">    NSDictionary *infoDict = [NSDictionary dictionaryWithObject:item.eventName forKey:ToDoItemKey]; </div><div class="line">    localNotif.userInfo = infoDict;</div><div class="line"></div><div class="line">    [[UIApplication sharedApplication] scheduleLocalNotification:localNotif];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>你可以通过调用<code>cancelLocalNotification</code>来取消特定的通知，也可以使用<code>cancelAllLocalNotifications</code>来取消所以的本地通知。这两张手动取消通知的方法都会关闭正在显示的通知。</p>
<p>应用也会发现本地通知非常有用当它们在后台运行的时候，当有用户感兴趣的新消息，数据和其他的一些东西出现时。这种情况下，应用可以使用<code>presentLocalNotificationNow:</code>来立即触发一个本地通知。（<code>iOS</code>允许应用在后台允许一小段时间）</p>
<h1 id="处理本地和远程通知"><a href="#处理本地和远程通知" class="headerlink" title="处理本地和远程通知"></a>处理本地和远程通知</h1><p><strong>当通知被交付时而应用不再前台运行时</strong>。这种情况下，系统显示这个通知，显示一个<code>alert</code>，<code>badge app icon</code>，或者播放一个声音，显示一个或多个动作按钮让用户点击。</p>
<p><strong>用户点击iOS8系统通知中一个动作按钮</strong>。这种情况下，iOS调用<code>application:handleActionWithIdentifier:forRemoteNotification:completionHandler:</code>或者<code>application:handleActionWithIdentifier:forLocalNotification:completionHandler:</code>。在上面两种情况下，你都能得到按钮的标识符以此来判断用户点击的哪个按钮。你也可以得到本地或者远程的通知，来获取你需要的数据。</p>
<p><strong>用户点击了默认的动作按钮或者点击了应用的图片</strong>。如果默认的动作按钮被用户点击，系统会启动应用程序然后调用<code>application:didFinishLaunchingWithOptions:</code>传入通知的<code>payload</code>或者本地通知对象。虽然<code>application:didFinishLaunchingWithOptions:</code>这个方法里不是处理通知的最佳时机，但是在这里获取通知的<code>payload</code>可以让你有机会在<code>handler</code>方法调用之前开始处理和通知相关的操作。</p>
<p>对于远程通知，系统也会调用<code>application:didReceiveRemoteNotification:fetchCompletionHandler:</code></p>
<p>如果在OS X上用户点击了应用图标，应用会调用<code>applicationDidFinishLaunching:</code>方法，然后应用代理可以获得远程通知。如果在iOS上点击应用图标，应用也会调用相同的方法，但是并不能获取通知内容。</p>
<p><strong>当通知被交付时应用程序在前台运行</strong>。应用会调用<code>application:didReceiveRemoteNotification:fetchCompletionHandler:</code>或者<code>application:didReceiveLocalNotification:</code>。（如果<code>application:didReceiveRemoteNotification:fetchCompletionHandler:</code>方法没有实现，系统会调用<code>application:didReceiveRemoteNotification:</code>这个方法）.在OS X中，系统会调用<code>application:didReceiveRemoteNotification:</code>方法。</p>
<p>应用程序可以使用传入的远程通知的<code>payload</code>或者在iOS中使用<code>UILocalNotification</code>的实例来帮助设置上下文处理通知相关的操作。在理想的情况下，应用代理在不同的平台执行下面的操作来传递远程和本地通知：</p>
<ul>
<li>对于OS X，应用代理会遵循<code>NSApplicationDelegate</code>协议，实现<code>application:didReceiveRemoteNotification:</code>方法</li>
<li>对于iOS，应用代理会遵循<code>UIApplicationDelegate</code>代理，实现<code>application:didReceiveRemoteNotification:fetchCompletionHandler:</code>或者<code>application:didReceiveLocalNotification:</code>方法。为了响应通知动作，实现<code>application:handleActionWithIdentifier:forLocalNotification:completionHandler:</code>或者<code>application:handleActionWithIdentifier:forRemoteNotification:completionHandler:</code></li>
</ul>
<p>下面的代码实现了<code>application:didFinishLaunchingWithOptions:</code>方法来处理本地通知。它从<code>options</code>字典中使用<code>UIApplicationLaunchOptionsLocalNotificationKey</code>键得到了一个<code>UILocalNotification</code>的实例。从<code>UILocalNotification</code>实例的<code>userInfo</code>字典中访问到<code>to-do</code>事项并设置应用的初始上下文。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (BOOL)application:(UIApplication *)app didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; </div><div class="line">    UILocalNotification *localNotif = [launchOptions objectForKey:UIApplicationLaunchOptionsLocalNotificationKey];</div><div class="line"></div><div class="line">    if (localNotif) &#123; </div><div class="line">    NSString *itemName = [localNotif.userInfo objectForKey:ToDoItemKey];</div><div class="line">    </div><div class="line">    [viewController displayItem:itemName]; // custom method</div><div class="line">    app.applicationIconBadgeNumber = localNotif.applicationIconBadgeNumber-1;</div><div class="line"></div><div class="line">    &#125; </div><div class="line">    [window addSubview:viewController.view]; </div><div class="line">    [window makeKeyAndVisible]; </div><div class="line">    return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>远程通知的实现也是类似的，除了你必须在每个平台定义一个常量作为键来访问通知的<code>payload</code>以外：</p>
<ul>
<li>在iOS中，在应用代理的<code>application:didFinishLaunchingWithOptions:</code>方法中使用<code>UIApplicationLaunchOptionsRemoteNotificationKey</code>键来获取<code>options</code>字典中的通知的<code>payload</code>。</li>
<li>在OS X中，在应用代理的<code>applicationDidFinishLaunching:</code>方法中使用<code>NSApplicationLaunchUserNotificationKey</code>键从传入的<code>NSNotification</code>对象的<code>userInfo</code>属性中获取<code>payload</code>字典。</li>
</ul>
<p><code>payload</code>是一个字典包含通知的<code>alert</code>消息，<code>badge number</code>,和声音等等。它也能包含应用程序用来设置初始的用户界面时的自定义数据。</p>
<blockquote>
<p>重要提示：远程通知的交付没有保证，所以你不应该使用通知来传递敏感数据或不能用其他方式获得得数据。</p>
</blockquote>
<p>当在应用代理的方法中处理远程通知时，应用代理会执行额外的任务。在应用启动后，代理应该和服务器连接然后下载数据。</p>
<blockquote>
<p>注意：客户端应用应该总是和服务器异步或者在次要线程通信。</p>
</blockquote>
<p>下面的代码显示了应用在前台运行时<code>application:didReceiveLocalNotification:</code>方法的实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (void)application:(UIApplication *)app didReceiveLocalNotification: (UILocalNotification *)notif &#123;</div><div class="line"></div><div class="line">    NSString *itemName = [notif.userInfo objectForKey:ToDoItemKey]; </div><div class="line">    [viewController displayItem:itemName]; // custom method </div><div class="line">    app.applicationIconBadgeNumber = notification.applicationIconBadgeNumber - 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果你想在应用在前台运行时获取远程通知，你应该实现<code>application:didReceiveRemoteNotification:fetchCompletionHandler:</code>方法。</p>
<h1 id="触发基于位置的本地通知"><a href="#触发基于位置的本地通知" class="headerlink" title="触发基于位置的本地通知"></a>触发基于位置的本地通知</h1><p>在<code>iOS8</code>和之后的系统中，可以创建基于地理位置的本地通知。当用户到达特定的地理位置区域时可以触发本地通知。<code>UILocalNotification</code>对象可以用一个<code>Core Location region</code>实例来配置。当用户进入或者离开时会触发相应的本地通知。你可以配置只触发一次或者在用户每次进入或离开时都触发本地通知。</p>
<h2 id="注册基于位置的本地通知"><a href="#注册基于位置的本地通知" class="headerlink" title="注册基于位置的本地通知"></a>注册基于位置的本地通知</h2><p>基于地理位置的本地通知需要应用支持<code>Core Location</code>。你必须配置一个<code>CLLocationManager</code>和对应的代理，然后向用户请求定位服务。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">CLLocationManager *locMan = [[CLLocationManager alloc] init]; </div><div class="line">// Set a delegate that receives callbacks that specify if your app is allowed to track the user&apos;s location </div><div class="line">locMan.delegate = self;</div><div class="line"></div><div class="line">// Request authorization to track the user’s location and enable location-based local notifications </div><div class="line">[locMan requestWhenInUseAuthorization];</div></pre></td></tr></table></figure></p>
<p>当你第一次申请定位服务时，<code>iOS</code>会请求用户同意或者拒绝应用的定位服务。<code>iOS</code>会使用<code>Info.plist</code>文件中<code>NSLocationWhenInUseUsageDescription</code>键所对应的文本来显示说明文字。如果要启动定位服务一定要包含这个键，否则<code>iOS</code>不会启动定位服务。</p>
<p>当应用在后台或者被挂起时，用户可能也可以看到基于地理位置的本地通知。然而，应用并不会收到任何回调，直到用户与<code>alert</code>交互应用才被允许获取用户的位置。</p>
<h2 id="处理地理位置回调"><a href="#处理地理位置回调" class="headerlink" title="处理地理位置回调"></a>处理地理位置回调</h2><p>在应用启动时，你应该检查位置通知的授权状态以此开启或者关闭位置通知。你必须处理的从<code>Core Location</code>返回的代理回调是<code>locationManager:didChangeAuthorizationStatus:</code>，这个方法里面会告诉你授权的状态。首先，通过回调中<code>kCLAuthorizationStatusAuthorizedWhenInUse</code>检查授权状态－－这意味着你的应用被允许来跟踪用户的位置。然后你就可以开始安排你的本地通知了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (void)locationManager:(CLLocationManager *)manager didChangeAuthorizationStatus:(CLAuthorizationStatus)status &#123;</div><div class="line"></div><div class="line">    // Check status to see if the app is authorized </div><div class="line">    BOOL canUseLocationNotifications = (status ==  </div><div class="line">    kCLAuthorizationStatusAuthorizedWhenInUse);</div><div class="line"></div><div class="line">    if (canUseLocationNotifications) &#123;</div><div class="line"></div><div class="line">        [self startShowingLocationNotifications]; // Custom method defined below </div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面的代码展示了如何创建一个基于地理位置的通知。就像普通的本地通知一样，你首先得创建一个<code>UILocalNotification</code>对象然后设置它的类型，这个例子中是一个<code>alert</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (void)startShowingNotifications &#123;</div><div class="line"></div><div class="line">    UILocalNotification *locNotification = [[UILocalNotification alloc] init];</div><div class="line">    locNotification.alertBody = @“You have arrived!”;</div><div class="line">    locNotification.regionTriggersOnce = YES;</div><div class="line"></div><div class="line">    locNotification.region = [[CLCircularRegion alloc] initWithCenter:LOC_COORDINATE          radius:LOC_RADIUS </div><div class="line">    identifier:LOC_IDENTIFIER];</div><div class="line"></div><div class="line">    [[UIApplication sharedApplication] scheduleLocalNotification:locNotification];</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>假设应用不在前台运行当用户到达上面代码指定的区域时，iOS会显示一个警告:”你已经到了”。下面一行指定当用户进入或离开此区域时警报只在第一次显示。这是默认的行为。但是如果对于应用来说必须每次都显示，就可以把它设置为<code>NO</code>。</p>
<p>然后，你创建了一个<code>CLCircularRegion</code>对象，并把它设置到<code>UILocalNotification</code>对象的<code>origin</code>属性。这个例子中我们使用了<code>CLCircularRegion</code>但是你也可以使用<code>CLBeaconRegion</code>或者任何<code>CLRegion</code>的子类。</p>
<p>最后，在<code>UIApplication</code>上调用<code>scheduleLocalNotification</code>来派发这个通知。</p>
<h2 id="处理基于位置的通知"><a href="#处理基于位置的通知" class="headerlink" title="处理基于位置的通知"></a>处理基于位置的通知</h2><p>假设应用被挂起时用户进入了上面指定的位置，一个显示”你来了”的警报会显示出来。你可以在<code>application:didFinishLaunchingWithOptions:</code>方法里面处理本地通知，或者当用户进入指定的区域时你的应用在前台运行，你的应用代理会收到<code>application:didReceiveLocalNotification:</code>消息。</p>
<p>处理位置通知的逻辑对于<code>application:didFinishLaunchingWithOptions:</code>和<code>application:didReceiveLocalNotification:</code>非常相似。这两个方法都会提供一个有<code>origin</code>属性的本地通知，如果<code>origin</code>属性不为<code>nil</code>，那么这就是一个位置通知。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (void)application:(UIApplication *)application didReceiveLocalNotification: (UILocalNotification *)notification &#123;</div><div class="line"></div><div class="line">    CLRegion *region = notification.region;</div><div class="line">    if (region) &#123;</div><div class="line"></div><div class="line">        [self tellFriendsUserArrivedAtRegion:region]; </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后，请记住当用户取消应用的定位授权时<code>application:didReceiveLocalNotification:</code>方法不会被调用。</p>
<h1 id="准备自定义的警报声音"><a href="#准备自定义的警报声音" class="headerlink" title="准备自定义的警报声音"></a>准备自定义的警报声音</h1><p>对于iOS中的远程通知，你可以指定自定义的声音当iOS显示本地或远程通知时播放这个声音。声音文件可以在应用的主<code>bundle</code>中，也可以在应用的数据容器的<code>Library/Sound</code>文件夹中。<br>自定义的声音由iOS的音频硬件播放出来，所以必须是下面的格式：</p>
<ul>
<li><strong><code>Linear PCM</code></strong></li>
<li><strong><code>MA4(IMA/IDPCM)</code></strong></li>
<li><strong><code>μLaw</code></strong></li>
<li><strong><code>aLaw</code></strong></li>
</ul>
<p>你可以使用<code>aiff</code>,<code>wav</code>,<code>caf</code>打包声音文件。然后在<code>Xcode</code>中添加这些声音文件到<code>bundle</code>或者到<code>Library/Sound</code>目录。</p>
<p>你可以使用<code>afconvert</code>来转换不同的音频文件。例如，可以使用下面的命令来把<code>16</code>位的<code>linear PCM</code>的系统声音<code>Submarine.aiff</code>转化为<code>CAF</code>文件格式的<code>IMA4</code>音频：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">afconvert /System/Library/Sounds/Submarine.aiff ~/Desktop/sub.caf -d ima4 -f caff -v</div></pre></td></tr></table></figure></p>
<p>可以通知把声音文件在<code>Quick Player</code>中打开然后使用<code>Show Movie Inspector</code>来检查音频的格式。</p>
<p>自定义的声音不能超过30s，如果超过这个限制，iOS不会使用这个音频文件而使用默认的系统声音来播放。</p>
<h1 id="传给服务器当前设备的语言选项"><a href="#传给服务器当前设备的语言选项" class="headerlink" title="传给服务器当前设备的语言选项"></a>传给服务器当前设备的语言选项</h1><p>如果应用程序不使用远程通知的<code>aps</code>字典中的<code>loc-key</code>和<code>loc-args</code>来获取本地化的警告消息，那么服务器需要提前本地化通知中的警报消息。要做到这一点，服务器需要知道设备的当前语言选项。然后应用需要传给服务器一个当前语言的标示，如<code>en</code>或者<code>fr</code>。</p>
<p>下面的代码展示了如何获取当前的语言并回穿给服务器。在iOS中，<code>NSLocale</code>的<code>preferredLanguages</code>属性一个只包含一个对象的数组：一个<code>NSString</code>对象表示当前的语言选项。<code>UTF8String</code>使用<code>utf-8</code>编码把该字符串转换成<code>c</code>字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSString *preferredLang = [[NSLocale preferredLanguages] objectAtIndex:0]; </div><div class="line">const char *langStr = [preferredLang UTF8String];</div><div class="line">[self sendProviderCurrentLanguage:langStr]; // custom method </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>应用需要在用户每次改变语言设置时都把语言选项发送给服务器。通过监听<code>NSCurrentLocaleDidChangeNotification</code>通知然后在回调中得到语言标示然后传给服务器，可以做到这一点。</p>
<p>如果设备的语言并不是应用支持的语言，服务器需要一种广泛使用的语言来本地化警告消息文本，如英语或西班牙语。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/08/27/iOS-push-notification-part-four/" class="prev">PREV</a><a href="/2016/08/27/iOS-push-notification-part-one/" class="next">NEXT</a></div><div data-thread-key="2016/08/27/iOS-push-notification-part-two/" data-title="iOS push notification part two" data-url="http://guopp.me/2016/08/27/iOS-push-notification-part-two/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"guopp"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2015 - 2017 <a href="http://guopp.me">guopp</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>